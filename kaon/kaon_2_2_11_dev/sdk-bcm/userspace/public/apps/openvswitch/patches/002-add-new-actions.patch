--- a/datapath/actions.c
+++ b/datapath/actions.c
@@ -37,6 +37,13 @@
 #include <net/dsfield.h>
 #include <net/mpls.h>
 #include <net/sctp/checksum.h>
+#ifdef CONFIG_OVS_SKIP_ACCEL_ACTION
+#include <net/netfilter/nf_conntrack_acct.h>
+#include <net/netfilter/nf_conntrack_helper.h>
+#include <net/netfilter/nf_conntrack_zones.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#include <net/netfilter/nf_conntrack_timeout.h>
+#endif
 
 #include "datapath.h"
 #include "conntrack.h"
@@ -1097,6 +1104,88 @@ static int execute_recirc(struct datapat
 	return clone_execute(dp, skb, key, recirc_id, NULL, 0, last, true);
 }
 
+#ifdef CONFIG_OVS_SKIP_ACCEL_ACTION
+
+#ifdef CONFIG_OVS_SKIP_ACCEL_ACTION_HOOK
+extern int ovs_skip_accel_hook(struct sk_buff *skb);
+#else
+static inline int ovs_skip_accel_hook(struct sk_buff *skb) { return 0; }
+#endif
+
+static int execute_accel(struct datapath *dp, struct sk_buff *skb,
+                          struct sw_flow_key *key,
+                          const struct nlattr *a)
+{
+	struct ovs_action_accel *accel = nla_data(a);
+	int status = 0;
+	u16 proto;
+	struct nf_conn *ctmark_zone;
+	struct nf_conntrack_tuple_hash *h;
+	struct nf_conntrack_tuple tuple = {};
+	struct nf_conntrack_zone nf_request_zone;
+	const struct nf_conn_counter *acct;
+	long long packets;
+	int accel_mode = 1;
+
+	if (accel->max_packets!=0) {
+		if (skb->protocol == htons(ETH_P_IP)) {
+			proto = NFPROTO_IPV4;
+		} else if (skb->protocol == htons(ETH_P_IPV6)) {
+			proto = NFPROTO_IPV6;
+		} else {
+			proto = NFPROTO_UNSPEC;
+		}
+		if (unlikely(proto==NFPROTO_UNSPEC)) {
+			return 0;
+		}
+		if (unlikely(!nf_ct_get_tuplepr(skb, skb_network_offset(skb), proto, &init_net, &tuple))) {
+			ovs_skip_accel_hook(skb);
+			return 0;
+		}
+		nf_ct_zone_init(&nf_request_zone, accel->ct_zone, NF_CT_DEFAULT_ZONE_DIR, 0);
+		h = nf_conntrack_find_get(&init_net, (const struct nf_conntrack_zone *) &nf_request_zone, &tuple);
+		if (NULL == h) {
+			ovs_skip_accel_hook(skb);
+			return 0;
+		}
+		ctmark_zone = nf_ct_tuplehash_to_ctrack(h);
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 6, 0))
+		acct = nf_conn_acct_find(ctmark_zone);
+#else
+		acct = nf_conn_acct_find(ctmark_zone)->counter;
+#endif
+		if (!acct) {
+			nf_ct_put(ctmark_zone);
+			ovs_skip_accel_hook(skb);
+			return 0;
+		}
+		packets = atomic64_read(&acct[IP_CT_DIR_ORIGINAL].packets);
+		packets += atomic64_read(&acct[IP_CT_DIR_REPLY].packets);
+		if (packets > accel->max_packets) {
+			/* update the mark value to next_mark */
+			spin_lock_bh(&ctmark_zone->lock);
+			ctmark_zone->mark = accel->next_mark;
+			spin_unlock_bh(&ctmark_zone->lock);
+		} else {
+			accel_mode = 0;
+		}
+		/*
+        * Release connection
+        */
+        nf_ct_put(ctmark_zone);
+	} else {
+		accel_mode = 0;
+	}
+
+	if (!accel_mode) {
+		ovs_skip_accel_hook(skb);
+	}
+
+	return 0;
+}
+#endif
+
+
 /* Execute a list of actions against 'skb'. */
 static int do_execute_actions(struct datapath *dp, struct sk_buff *skb,
 			      struct sw_flow_key *key,
@@ -1110,6 +1199,14 @@ static int do_execute_actions(struct dat
 		int err = 0;
 
 		switch (nla_type(a)) {
+		case OVS_ACTION_ATTR_ACCEL: {
+#ifdef CONFIG_OVS_SKIP_ACCEL_ACTION
+			err = execute_accel(dp, skb, key, a);
+#else
+			WARN_ONCE(1, "OVS_SKIP_ACCEL_ACTION is not enabled\n");
+#endif
+			break;
+		}
 		case OVS_ACTION_ATTR_OUTPUT: {
 			int port = nla_get_u32(a);
 			struct sk_buff *clone;
--- a/datapath/flow_netlink.c
+++ b/datapath/flow_netlink.c
@@ -73,6 +73,7 @@ static bool actions_may_change_flow(cons
 		u16 action = nla_type(nla);
 
 		switch (action) {
+		case OVS_ACTION_ATTR_ACCEL:
 		case OVS_ACTION_ATTR_OUTPUT:
 		case OVS_ACTION_ATTR_RECIRC:
 		case OVS_ACTION_ATTR_TRUNC:
@@ -2487,6 +2488,7 @@ static int __ovs_nla_copy_actions(struct
 	nla_for_each_nested(a, attr, rem) {
 		/* Expected argument lengths, (u32)-1 for variable length. */
 		static const u32 action_lens[OVS_ACTION_ATTR_MAX + 1] = {
+			[OVS_ACTION_ATTR_ACCEL] = sizeof(struct ovs_action_accel),
 			[OVS_ACTION_ATTR_OUTPUT] = sizeof(u32),
 			[OVS_ACTION_ATTR_RECIRC] = sizeof(u32),
 			[OVS_ACTION_ATTR_USERSPACE] = (u32)-1,
@@ -2514,6 +2516,8 @@ static int __ovs_nla_copy_actions(struct
 
 		skip_copy = false;
 		switch (type) {
+		case OVS_ACTION_ATTR_ACCEL:
+			break;
 		case OVS_ACTION_ATTR_UNSPEC:
 			return -EINVAL;
 
--- a/datapath/linux/compat/include/linux/openvswitch.h
+++ b/datapath/linux/compat/include/linux/openvswitch.h
@@ -661,6 +661,12 @@ enum ovs_userspace_attr {
 
 #define OVS_USERSPACE_ATTR_MAX (__OVS_USERSPACE_ATTR_MAX - 1)
 
+struct ovs_action_accel {
+	uint32_t ct_zone;    /* ct_zone number */
+	uint32_t max_packets; /* packets deferral number, if set to 0 means not specified */
+	uint32_t next_mark; /* if packet counts reach max_packets, to update ct marking value */
+};
+
 struct ovs_action_trunc {
 	uint32_t max_len; /* Max packet size in bytes. */
 };
@@ -924,6 +930,7 @@ enum ovs_action_attr {
 	OVS_ACTION_ATTR_TRUNC,        /* u32 struct ovs_action_trunc. */
 	OVS_ACTION_ATTR_PUSH_ETH,     /* struct ovs_action_push_eth. */
 	OVS_ACTION_ATTR_POP_ETH,      /* No argument. */
+	OVS_ACTION_ATTR_ACCEL,        /* struct ovs_action_accel */
 
 #ifndef __KERNEL__
 	OVS_ACTION_ATTR_TUNNEL_PUSH,   /* struct ovs_action_push_tnl*/
--- a/include/openvswitch/ofp-actions.h
+++ b/include/openvswitch/ofp-actions.h
@@ -134,7 +134,8 @@ struct vl_mff_map;
     OFPACT(CLEAR_ACTIONS,   ofpact_null,        ofpact, "clear_actions") \
     OFPACT(WRITE_ACTIONS,   ofpact_nest,        actions, "write_actions") \
     OFPACT(WRITE_METADATA,  ofpact_metadata,    ofpact, "write_metadata") \
-    OFPACT(GOTO_TABLE,      ofpact_goto_table,  ofpact, "goto_table")
+    OFPACT(GOTO_TABLE,      ofpact_goto_table,  ofpact, "goto_table") \
+    OFPACT(ACCEL, ofpact_accel, 		ofpact, "skip_accel")
 
 /* enum ofpact_type, with a member OFPACT_<ENUM> for each action. */
 enum OVS_PACKED_ENUM ofpact_type {
@@ -960,6 +961,18 @@ struct ofpact_goto_table {
     uint8_t table_id;
 };
 
+/* OFPACT_ACCEL.
+ *
+ * Used for OFPAT_ACCEL */
+struct ofpact_accel {
+    OFPACT_PADDED_MEMBERS(
+	struct ofpact ofpact;
+	uint32_t ct_zone;
+	uint32_t max_packets;
+	uint32_t next_mark;
+    );
+};
+
 /* OFPACT_GROUP.
  *
  * Used for OFPAT11_GROUP. */
--- a/lib/dpif-netdev.c
+++ b/lib/dpif-netdev.c
@@ -5428,7 +5428,9 @@ dp_execute_cb(void *aux_, struct dp_pack
         dp_netdev_run_meter(pmd->dp, packets_, nl_attr_get_u32(a),
                             time_msec());
         break;
-
+    case OVS_ACTION_ATTR_ACCEL:
+	/* Not implemented yet. */
+	break;
     case OVS_ACTION_ATTR_PUSH_VLAN:
     case OVS_ACTION_ATTR_POP_VLAN:
     case OVS_ACTION_ATTR_PUSH_MPLS:
--- a/lib/dpif.c
+++ b/lib/dpif.c
@@ -1162,7 +1162,9 @@ dpif_execute_helper_cb(void *aux_, struc
             aux->meter_action = action;
         }
 	break;
-
+    case OVS_ACTION_ATTR_ACCEL:
+        /* Not implemented yet. */
+        break;
     case OVS_ACTION_ATTR_CT:
     case OVS_ACTION_ATTR_OUTPUT:
     case OVS_ACTION_ATTR_TUNNEL_PUSH:
--- a/lib/odp-execute.c
+++ b/lib/odp-execute.c
@@ -639,6 +639,7 @@ requires_datapath_assistance(const struc
     case OVS_ACTION_ATTR_RECIRC:
     case OVS_ACTION_ATTR_CT:
     case OVS_ACTION_ATTR_METER:
+    case OVS_ACTION_ATTR_ACCEL:
         return true;
 
     case OVS_ACTION_ATTR_SET:
@@ -839,6 +840,9 @@ odp_execute_actions(void *dp, struct dp_
             break;
         }
 
+	case OVS_ACTION_ATTR_ACCEL:
+		/* Not implemented yet. */
+		break;
         case OVS_ACTION_ATTR_OUTPUT:
         case OVS_ACTION_ATTR_TUNNEL_PUSH:
         case OVS_ACTION_ATTR_TUNNEL_POP:
--- a/lib/odp-util.c
+++ b/lib/odp-util.c
@@ -110,6 +110,7 @@ odp_action_len(uint16_t type)
     }
 
     switch ((enum ovs_action_attr) type) {
+    case OVS_ACTION_ATTR_ACCEL: return sizeof(struct ovs_action_accel);
     case OVS_ACTION_ATTR_OUTPUT: return sizeof(uint32_t);
     case OVS_ACTION_ATTR_TRUNC: return sizeof(struct ovs_action_trunc);
     case OVS_ACTION_ATTR_TUNNEL_PUSH: return ATTR_LEN_VARIABLE;
@@ -956,6 +957,12 @@ format_odp_action(struct ds *ds, const s
     }
 
     switch (type) {
+    case OVS_ACTION_ATTR_ACCEL: {
+	const struct ovs_action_accel *accel =
+                       nl_attr_get_unspec(a, sizeof *accel);
+	ds_put_format(ds, "skip_accel(ct_zone=%"PRIu32",max_packets=%"PRIu32",next_mark=%"PRIu32")", accel->ct_zone, accel->max_packets, accel->next_mark);
+	break;
+    }
     case OVS_ACTION_ATTR_METER:
         ds_put_format(ds, "meter(%"PRIu32")", nl_attr_get_u32(a));
         break;
@@ -1926,6 +1933,26 @@ static int
 parse_odp_action(const char *s, const struct simap *port_names,
                  struct ofpbuf *actions)
 {
+
+    {
+	uint32_t ct_zone;
+	uint32_t max_packets;
+	uint32_t next_mark;
+	int n;
+
+	if (ovs_scan(s, "skip_accel(ct_zone=%"SCNi32",max_packets=%"SCNi32",next_mark=%"SCNi32")%n", &ct_zone, &max_packets, &next_mark, &n)) {
+		struct ovs_action_accel *accel;
+
+		accel = nl_msg_put_unspec_uninit(actions,
+			OVS_ACTION_ATTR_ACCEL, sizeof *accel);
+		accel->ct_zone = ct_zone;
+		accel->max_packets = max_packets;
+		accel->next_mark = next_mark;
+		return n;
+	}
+    }
+
+
     {
         uint32_t port;
         int n;
--- a/lib/ofp-actions.c
+++ b/lib/ofp-actions.c
@@ -348,6 +348,9 @@ enum ofp_raw_action_type {
     /* NX1.3+(47): struct nx_action_decap, ... */
     NXAST_RAW_DECAP,
 
+    /* OF1.0+(29): struct ofp_action_accel. */
+    OFPAT_RAW_ACCEL,
+
 /* ## ------------------ ## */
 /* ## Debugging actions. ## */
 /* ## ------------------ ## */
@@ -428,6 +431,7 @@ struct ofpact *
 ofpact_next_flattened(const struct ofpact *ofpact)
 {
     switch (ofpact->type) {
+    case OFPACT_ACCEL:
     case OFPACT_OUTPUT:
     case OFPACT_GROUP:
     case OFPACT_CONTROLLER:
@@ -632,6 +636,91 @@ parse_truncate_subfield(struct ofpact_ou
     return NULL;
 }
 
+/* Accel actions. */
+struct ofp_action_accel {
+    ovs_be16 type;                    /* OFPAT11_OUTPUT. */
+    ovs_be16 len;                     /* Length is 16. */
+    ovs_be32 ct_zone;                 /* CT zone number. */
+    ovs_be32 max_packets;	      /* Maximum deferral number. */
+    ovs_be32 next_mark;               /* Next mark vlaue if maximum deferral numbers reach. */
+};
+
+static enum ofperr
+decode_OFPAT_RAW_ACCEL(const struct ofp_action_accel *oac,
+                         enum ofp_version ofp_version OVS_UNUSED,
+                         struct ofpbuf *out)
+{
+	struct ofpact_accel *accel=NULL;
+
+	accel = ofpact_put_ACCEL(out);
+	accel->ct_zone = ntohl(oac->ct_zone);
+	accel->max_packets = ntohl(oac->max_packets);
+	accel->next_mark = ntohl(oac->next_mark);
+
+	return 0;
+}
+
+
+static void
+encode_ACCEL(const struct ofpact_accel *accel,
+             enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)
+{
+	struct ofp_action_accel *oac;
+
+	oac = put_OFPAT_ACCEL(out);
+	oac->ct_zone = htonl(accel->ct_zone);
+	oac->max_packets = htonl(accel->max_packets);
+	oac->next_mark = htonl(accel->next_mark);
+}
+
+static char * OVS_WARN_UNUSED_RESULT
+parse_ACCEL(char *arg,
+               const struct ofputil_port_map *port_map OVS_UNUSED,
+               struct ofpbuf *ofpacts,
+               enum ofputil_protocol *usable_protocols OVS_UNUSED)
+{
+	struct ofpact_accel *accel;
+	uint32_t ct_zone = 0;
+	uint32_t max_packets = 0;
+	uint32_t next_mark = 0;
+	char *key, *value;
+	char *error;
+
+	accel = ofpact_put_ACCEL(ofpacts);
+
+	while (ofputil_parse_key_value(&arg, &key, &value)) {
+		if (!strcmp(key, "ct_zone")) {
+                        error = str_to_u32(value, &ct_zone);
+                        if (error) {
+                                return error;
+                        }
+                } else if (!strcmp(key, "max_packets")) {
+                        error = str_to_u32(value, &max_packets);
+                        if (error) {
+                                return error;
+                        }
+                } else if (!strcmp(key, "next_mark")) {
+                        error = str_to_u32(value, &next_mark);
+                        if (error) {
+                                return error;
+                        }
+                }
+	}
+	accel->ct_zone = ct_zone;
+	accel->max_packets = max_packets;
+	accel->next_mark = next_mark;
+	return NULL;
+}
+
+
+static void
+format_ACCEL(const struct ofpact_accel *a,
+                const struct ofputil_port_map *port_map OVS_UNUSED, struct ds *s)
+{
+	ds_put_format(s, "skip_accel(ct_zone=%"PRIu32",max_packets=%"PRIu32",next_mark=%"PRIu32")", a->ct_zone, a->max_packets, a->next_mark);
+}
+
+
 static char * OVS_WARN_UNUSED_RESULT
 parse_OUTPUT(const char *arg,
              const struct ofputil_port_map *port_map,
@@ -7151,6 +7240,7 @@ ofpact_is_set_or_move_action(const struc
     case OFPACT_DEBUG_RECIRC:
     case OFPACT_ENCAP:
     case OFPACT_DECAP:
+    case OFPACT_ACCEL:
         return false;
     default:
         OVS_NOT_REACHED();
@@ -7227,6 +7317,7 @@ ofpact_is_allowed_in_actions_set(const s
     case OFPACT_METER:
     case OFPACT_WRITE_ACTIONS:
     case OFPACT_WRITE_METADATA:
+    case OFPACT_ACCEL:
         return false;
     default:
         OVS_NOT_REACHED();
@@ -7446,6 +7537,7 @@ ovs_instruction_type_from_ofpact_type(en
     case OFPACT_NAT:
     case OFPACT_ENCAP:
     case OFPACT_DECAP:
+    case OFPACT_ACCEL:
     default:
         return OVSINST_OFPIT11_APPLY_ACTIONS;
     }
@@ -8131,7 +8223,8 @@ ofpact_check__(enum ofputil_protocol *us
             flow->dl_type = OVS_BE16_MAX;
         }
         return 0;
-
+    case OFPACT_ACCEL:
+        return 0;
     default:
         OVS_NOT_REACHED();
     }
@@ -8627,6 +8720,7 @@ ofpact_outputs_to_port(const struct ofpa
     case OFPACT_NAT:
     case OFPACT_ENCAP:
     case OFPACT_DECAP:
+    case OFPACT_ACCEL:
     default:
         return false;
     }
--- a/ofproto/ofproto-dpif-ipfix.c
+++ b/ofproto/ofproto-dpif-ipfix.c
@@ -2827,6 +2827,7 @@ dpif_ipfix_read_actions(const struct flo
         case OVS_ACTION_ATTR_ENCAP_NSH:
         case OVS_ACTION_ATTR_DECAP_NSH:
         case OVS_ACTION_ATTR_UNSPEC:
+        case OVS_ACTION_ATTR_ACCEL:
         case __OVS_ACTION_ATTR_MAX:
         default:
             break;
--- a/ofproto/ofproto-dpif-xlate.c
+++ b/ofproto/ofproto-dpif-xlate.c
@@ -4602,6 +4602,7 @@ xlate_fixup_actions(struct ofpbuf *b, co
         case OVS_ACTION_ATTR_ENCAP_NSH:
         case OVS_ACTION_ATTR_DECAP_NSH:
         case OVS_ACTION_ATTR_METER:
+	case OVS_ACTION_ATTR_ACCEL:
             ofpbuf_put(b, a, nl_attr_len_pad(a, left));
             break;
 
@@ -5539,6 +5540,7 @@ reversible_actions(const struct ofpact *
         case OFPACT_OUTPUT_TRUNC:
         case OFPACT_ENCAP:
         case OFPACT_DECAP:
+        case OFPACT_ACCEL:
             return false;
         }
     }
@@ -5808,6 +5810,7 @@ freeze_unroll_actions(const struct ofpac
         case OFPACT_CT:
         case OFPACT_CT_CLEAR:
         case OFPACT_NAT:
+        case OFPACT_ACCEL:
             /* These may not generate PACKET INs. */
             break;
 
@@ -6312,6 +6315,7 @@ recirc_for_mpls(const struct ofpact *a,
     case OFPACT_WRITE_ACTIONS:
     case OFPACT_WRITE_METADATA:
     case OFPACT_GOTO_TABLE:
+    case OFPACT_ACCEL:
     default:
         break;
     }
@@ -6348,6 +6352,18 @@ xlate_ofpact_unroll_xlate(struct xlate_c
                  "cookie=%#"PRIx64, a->rule_table_id, a->rule_cookie);
 }
 
+static void compose_accel_action(struct xlate_ctx *ctx, struct ofpact_accel *op)
+{
+	struct ovs_action_accel *accel;
+
+	accel = nl_msg_put_unspec_uninit(ctx->odp_actions,
+                     OVS_ACTION_ATTR_ACCEL, sizeof *accel);
+
+	accel->ct_zone = op->ct_zone;
+	accel->max_packets = op->max_packets;
+	accel->next_mark = op->next_mark;
+}
+
 static void
 do_xlate_actions(const struct ofpact *ofpacts, size_t ofpacts_len,
                  struct xlate_ctx *ctx)
@@ -6396,6 +6412,9 @@ do_xlate_actions(const struct ofpact *of
         }
 
         switch (a->type) {
+	case OFPACT_ACCEL:
+	    compose_accel_action(ctx, ofpact_get_ACCEL(a));
+	    break;
         case OFPACT_OUTPUT:
             xlate_output_action(ctx, ofpact_get_OUTPUT(a)->port,
                                 ofpact_get_OUTPUT(a)->max_len, true);
