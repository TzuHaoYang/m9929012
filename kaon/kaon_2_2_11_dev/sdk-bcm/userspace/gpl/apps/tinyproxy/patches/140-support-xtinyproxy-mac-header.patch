diff --git a/configure.ac b/configure.ac
index 6ddbcc0..7d99c2a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -52,6 +52,18 @@ if test x"$xtinyproxy_enabled" = x"yes"; then
     AC_DEFINE(XTINYPROXY_ENABLE)
 fi
 
+dnl Check to see if the XTinyproxymac header is to be included
+AH_TEMPLATE([XTINYPROXYMAC_ENABLE],
+	    [Define if you want to have the peer's mac address included in a XTinyproxymac header sent to the server.])
+TP_ARG_ENABLE(xtinyproxymac,
+              [Include the X-Tinyproxy-MAC header (default is YES)],
+              yes)
+
+if test x"$xtinyproxymac_enabled" = x"yes"; then
+    AC_DEFINE(XTINYPROXYMAC_ENABLE)
+fi
+
+
 dnl Include filtering for domain/URLs
 AH_TEMPLATE([FILTER_ENABLE],
 	    [Defined if you would like filtering code included.])
diff --git a/src/Makefile.am b/src/Makefile.am
index 50e645b..a95bafd 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -42,6 +42,7 @@ tinyproxy_SOURCES = \
 	sock.c sock.h \
 	stats.c stats.h \
 	text.c text.h \
+    nf_util_neigh.c nf_util_neigh.h \
 	main.c main.h \
 	utils.c utils.h \
 	vector.c vector.h \
@@ -56,4 +57,4 @@ EXTRA_tinyproxy_SOURCES = filter.c filter.h \
 	reverse-proxy.c reverse-proxy.h \
 	transparent-proxy.c transparent-proxy.h
 tinyproxy_DEPENDENCIES = @ADDITIONAL_OBJECTS@
-tinyproxy_LDADD = @ADDITIONAL_OBJECTS@ -lpthread
+tinyproxy_LDADD = @ADDITIONAL_OBJECTS@ -lpthread -lmnl
diff --git a/src/common.h b/src/common.h
index 47a1ed1..7860679 100644
--- a/src/common.h
+++ b/src/common.h
@@ -69,6 +69,7 @@
 #  include	<grp.h>
 #  include	<pwd.h>
 #  include      <regex.h>
+#  include  <pthread.h>
 
 /* rest - some oddball headers */
 #ifdef HAVE_VALUES_H
diff --git a/src/conf.c b/src/conf.c
index 9dd6da2..8537b29 100644
--- a/src/conf.c
+++ b/src/conf.c
@@ -158,6 +158,7 @@ static HANDLE_FUNC (handle_user);
 static HANDLE_FUNC (handle_viaproxyname);
 static HANDLE_FUNC (handle_disableviaheader);
 static HANDLE_FUNC (handle_xtinyproxy);
+static HANDLE_FUNC (handle_xtinyproxymac);
 
 #ifdef UPSTREAM_SUPPORT
 static HANDLE_FUNC (handle_upstream);
@@ -207,6 +208,7 @@ struct {
         STDCONF ("statfile", STR, handle_statfile),
         STDCONF ("stathost", STR, handle_stathost),
         STDCONF ("xtinyproxy",  BOOL, handle_xtinyproxy),
+        STDCONF ("xtinyproxy-mac",  BOOL, handle_xtinyproxymac),
         /* boolean arguments */
         STDCONF ("syslog", BOOL, handle_syslog),
         STDCONF ("bindsame", BOOL, handle_bindsame),
@@ -685,6 +687,18 @@ static HANDLE_FUNC (handle_xtinyproxy)
 #endif
 }
 
+static HANDLE_FUNC (handle_xtinyproxymac)
+{
+#ifdef XTINYPROXYMAC_ENABLE
+        return set_bool_arg (&conf->add_xtinyproxymac, line, &match[2]);
+#else
+        fprintf (stderr,
+                 "XTinyproxy-MAC NOT Enabled! Recompile with --enable-xtinyproxymac\n");
+        return 1;
+#endif
+}
+
+
 static HANDLE_FUNC (handle_syslog)
 {
         return set_bool_arg (&conf->syslog, line, &match[2]);
diff --git a/src/conf.h b/src/conf.h
index 085169d..5c3e260 100644
--- a/src/conf.h
+++ b/src/conf.h
@@ -56,6 +56,10 @@ struct config_s {
 #ifdef XTINYPROXY_ENABLE
         unsigned int add_xtinyproxy; /* boolean */
 #endif
+#ifdef XTINYPROXYMAC_ENABLE
+        unsigned int add_xtinyproxymac; /* boolean */
+#endif
+
 #ifdef REVERSE_SUPPORT
         struct reversepath *reversepath_list;
         unsigned int reverseonly;       /* boolean */
diff --git a/src/conns.c b/src/conns.c
index 505b5c4..5ec4439 100644
--- a/src/conns.c
+++ b/src/conns.c
@@ -29,12 +29,14 @@
 #include "heap.h"
 #include "log.h"
 #include "stats.h"
+#include "nf_util_neigh.h"
 
 struct conn_s *initialize_conn (int client_fd, const char *ipaddr,
                                 const char *sock_ipaddr)
 {
         struct conn_s *connptr;
         struct buffer_s *cbuffer, *sbuffer;
+        char mac[MAX_MAC_STR_SIZE] = {0};
 
         assert (client_fd >= 0);
 
@@ -79,6 +81,12 @@ struct conn_s *initialize_conn (int client_fd, const char *ipaddr,
                                    safestrdup (sock_ipaddr) : NULL);
         connptr->client_ip_addr = safestrdup (ipaddr);
 
+        if (!nf_neigh_get_mac(ipaddr, mac)) {
+                log_message(LOG_ERR, "Couldn't find mac for client ip[%s]", ipaddr);
+        }
+
+        connptr->client_mac_addr = safestrdup(mac);
+
         connptr->upstream_proxy = NULL;
 
         update_stats (STAT_OPEN);
@@ -132,6 +140,8 @@ void destroy_conn (struct conn_s *connptr)
                 safefree (connptr->server_ip_addr);
         if (connptr->client_ip_addr)
                 safefree (connptr->client_ip_addr);
+        if (connptr->client_mac_addr)
+                safefree (connptr->client_mac_addr);
 
 #ifdef REVERSE_SUPPORT
         if (connptr->reversepath)
diff --git a/src/conns.h b/src/conns.h
index 393e5d4..8ef85f1 100644
--- a/src/conns.h
+++ b/src/conns.h
@@ -66,6 +66,11 @@ struct conn_s {
          */
         char *client_ip_addr;
 
+        /*
+         * Store the client's MAC information
+         */
+        char *client_mac_addr;
+
         /*
          * Store the incoming request's HTTP protocol.
          */
diff --git a/src/html-error.c b/src/html-error.c
index 3018b46..5bd4a40 100644
--- a/src/html-error.c
+++ b/src/html-error.c
@@ -262,6 +262,7 @@ int add_standard_vars (struct conn_s *connptr)
         ADD_VAR_RET ("cause", connptr->error_string);
         ADD_VAR_RET ("request", connptr->request_line);
         ADD_VAR_RET ("clientip", connptr->client_ip_addr);
+        ADD_VAR_RET ("clientmac", connptr->client_mac_addr);
 
         /* The following value parts are all non-NULL and will
          * trigger warnings in ADD_VAR_RET(), so we use
diff --git a/src/main.c b/src/main.c
index fc5ad45..71b64d3 100644
--- a/src/main.c
+++ b/src/main.c
@@ -43,6 +43,7 @@
 #include "sock.h"
 #include "stats.h"
 #include "utils.h"
+#include "nf_util_neigh.h"
 
 /*
  * Global Structures
@@ -275,7 +276,8 @@ int
 main (int argc, char **argv)
 {
         int opt, daemonized = TRUE;
-
+        pthread_attr_t *attrp, attr;
+        struct nf_neigh_context *ctxt;
         srand(time(NULL)); /* for hashmap seeds */
 
         /* Only allow u+rw bits. This may be required for some versions
@@ -349,6 +351,22 @@ main (int argc, char **argv)
                 filter_init ();
 #endif /* FILTER_ENABLE */
 
+#ifdef XTINYPROXYMAC_ENABLE
+        nf_neigh_init ();
+        if (config->add_xtinyproxymac)
+        {
+                ctxt = nf_neigh_get_context ();
+                attrp = 0;
+                if (pthread_attr_init (&attr) == 0) {
+                    attrp = &attr;
+                    pthread_attr_setstacksize (attrp, 256*1024);
+                }
+
+                if (pthread_create (&ctxt->neigh_thread, attrp, neigh_main_loop, ctxt) != 0) {
+                    log_message (LOG_ERR, "Couldn't start listening on neigh updates.");
+                }
+        }
+#endif /* TINYPROXYMAC_ENABLE */
         /* Start listening on the selected port. */
         if (child_listening_sockets(config->listen_addrs, config->port) < 0) {
                 fprintf (stderr, "%s: Could not create listening sockets.\n",
diff --git a/src/nf_util_neigh.c b/src/nf_util_neigh.c
new file mode 100644
index 0000000..a91d95b
--- /dev/null
+++ b/src/nf_util_neigh.c
@@ -0,0 +1,398 @@
+/* This example is placed in the public domain. */
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <time.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <net/if.h>
+#include <libmnl/libmnl.h>
+#include <linux/if_link.h>
+#include <linux/rtnetlink.h>
+#include <sys/socket.h>
+#include <netdb.h>
+
+#include "log.h"
+#include "hashmap.h"
+#include "nf_util_neigh.h"
+
+#define ARP_BUCKETS 256
+
+struct nf_neigh_context g_ctxt;
+
+struct nf_neigh_context *nf_neigh_get_context(void)
+{
+    return &g_ctxt;
+}
+
+unsigned int nf_neigh_get_mac(const char *ip, char *mac)
+{
+    struct nf_neigh_context  *ctxt = nf_neigh_get_context();
+    macaddr_t *pmac;
+    ssize_t len = 0;
+
+    if (!ctxt) return 0;
+
+    len = hashmap_entry_by_key (ctxt->arptable, ip, (void * *) &pmac);
+    if (len > 0)
+    {
+        if (snprintf(mac, MAX_MAC_STR_SIZE, PRI_macaddr_t, FMT_macaddr_pt(pmac)) > 0)
+            return 1;
+    }
+    return 0;
+}
+
+static int
+util_data_attr_cb(const struct nlattr *attr, void *data)
+{
+    const struct nlattr **tb = data;
+    int type = mnl_attr_get_type(attr);
+
+    /* skip unsupported attribute in user-space */
+    if (mnl_attr_type_valid(attr, IFA_MAX) < 0)
+        return MNL_CB_OK;
+
+    switch(type) {
+    case NDA_DST:
+        if (mnl_attr_validate(attr, MNL_TYPE_BINARY) < 0) {
+            perror("mnl_attr_validate");
+            return MNL_CB_ERROR;
+        }
+        break;
+    case NDA_LLADDR:
+        if (mnl_attr_validate(attr, MNL_TYPE_BINARY) < 0) {
+            perror("mnl_attr_validate");
+            return MNL_CB_ERROR;
+        }
+        break;
+    }
+    tb[type] = attr;
+    return MNL_CB_OK;
+}
+
+int neigh_add_to_map(struct nf_neigh_info *neigh_info)
+{
+    char ipstr[INET6_ADDRSTRLEN] = { 0 };
+    int rc = -1;
+    struct nf_neigh_context *ctxt;
+
+    ctxt = nf_neigh_get_context();
+
+    inet_ntop(neigh_info->af_family, neigh_info->ipaddr, ipstr, sizeof(ipstr));
+
+    pthread_mutex_lock(&ctxt->arptable_lock);
+    if (hashmap_search (ctxt->arptable, ipstr) > 0) {
+        hashmap_remove (ctxt->arptable, ipstr);
+    }
+    rc = hashmap_insert (ctxt->arptable, ipstr, neigh_info->hwaddr, sizeof(macaddr_t));
+    pthread_mutex_unlock(&ctxt->arptable_lock);
+
+    return rc;
+}
+
+int neigh_del_from_map(struct nf_neigh_info *neigh_info)
+{
+    char ipstr[INET6_ADDRSTRLEN] = { 0 };
+    int rc = -1;
+    struct nf_neigh_context *ctxt;
+
+    ctxt = nf_neigh_get_context();
+    inet_ntop(neigh_info->af_family, neigh_info->ipaddr, ipstr, sizeof(ipstr));
+
+    pthread_mutex_lock(&ctxt->arptable_lock);
+    rc = hashmap_remove(ctxt->arptable, ipstr);
+    pthread_mutex_unlock(&ctxt->arptable_lock);
+
+    return rc;
+}
+
+static void process_neigh_event(struct nf_neigh_info *neigh_info)
+{
+    char ipstr[INET6_ADDRSTRLEN] = { 0 };
+    macaddr_t mac = { { 0 } };
+    macaddr_t *pmac;
+    unsigned int rc;
+
+    pmac = (macaddr_t *)((neigh_info->hwaddr != NULL) ? neigh_info->hwaddr : &mac);
+    inet_ntop(neigh_info->af_family, neigh_info->ipaddr, ipstr, sizeof(ipstr));
+    log_message(LOG_INFO, "Entry with mac "  PRI_macaddr_t
+                           " for ip[%s]: %s",
+                           FMT_macaddr_pt(pmac), ipstr,
+                           (neigh_info->add && !neigh_info->del) ? "added" : "deleted");
+
+    if (neigh_info->add)
+    {
+        rc = neigh_add_to_map(neigh_info);
+        if (rc != 0)
+        {
+            log_message(LOG_ERR, "add to cache failed");
+            return;
+        }
+    }
+    else if (neigh_info->del)
+    {
+        neigh_del_from_map(neigh_info);
+        return;
+    }
+}
+
+
+/**
+ * @brief mnl callback processing a netlink neighbor message
+ */
+static int util_neigh_cb(const struct nlmsghdr *nlh, void *data)
+{
+    char ipstr[INET6_ADDRSTRLEN] = { 0 };
+    struct nlattr *tb[IFA_MAX + 1] = {};
+    struct nf_neigh_info neigh_info;
+    struct nf_neigh_context *ctxt;
+    struct ndmsg *ndm;
+    unsigned int add_entry;
+    unsigned int del_entry;
+    int af_family;
+    void *macaddr;
+    void *ipaddr;
+    int mnl_ret;
+    int ret;
+
+    ctxt = nf_neigh_get_context();
+    mnl_ret = MNL_CB_OK;
+
+    add_entry = 0;
+    del_entry = 0;
+
+    ndm = mnl_nlmsg_get_payload(nlh);
+    if (ndm == NULL) return MNL_CB_OK;
+
+    ret = mnl_attr_parse(nlh, sizeof(*ndm), util_data_attr_cb, tb);
+    if (ret == MNL_CB_ERROR) return MNL_CB_ERROR;
+
+    if (tb[NDA_DST] == NULL) return mnl_ret;
+
+    ipaddr = mnl_attr_get_payload(tb[NDA_DST]);
+
+    af_family = ndm->ndm_family;
+    inet_ntop(af_family, ipaddr, ipstr, sizeof(ipstr));
+
+    switch (ndm->ndm_state)
+    {
+        case NUD_PERMANENT:
+        case NUD_REACHABLE:
+        case NUD_STALE:
+            add_entry = 1;
+            break;
+        case NUD_INCOMPLETE:
+        case NUD_DELAY:
+        case NUD_PROBE:
+        case NUD_FAILED:
+        case NUD_NOARP:
+            del_entry = 1;
+            break;
+        default:
+            return mnl_ret;
+    }
+
+    macaddr = NULL;
+    if (tb[NDA_LLADDR] != NULL)
+    {
+        macaddr = mnl_attr_get_payload(tb[NDA_LLADDR]);
+    }
+
+    memset(&neigh_info, 0, sizeof(neigh_info));
+    neigh_info.af_family = af_family;
+    neigh_info.ipaddr = ipaddr;
+    neigh_info.hwaddr = macaddr;
+    neigh_info.add = add_entry;
+    neigh_info.del = del_entry;
+    if (ctxt->neigh_cb) ctxt->neigh_cb(&neigh_info);
+
+    return mnl_ret;
+}
+
+/**
+ * @brief dump the neighbors table for the given inet family
+ *
+ * @param af_family the inet family
+ */
+unsigned int nf_util_dump_neighs(int af_family)
+{
+    char buf[MNL_SOCKET_BUFFER_SIZE];
+    struct mnl_socket *nl;
+    struct nlmsghdr *nlh;
+    struct rtgenmsg *rt;
+    unsigned int portid;
+    unsigned int seq;
+    unsigned int rc;
+    int ret;
+
+    nlh = mnl_nlmsg_put_header(buf);
+    nlh->nlmsg_type = RTM_GETNEIGH;
+    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
+    nlh->nlmsg_seq = seq = time(NULL) + 1;
+
+    rt = mnl_nlmsg_put_extra_header(nlh, sizeof(struct rtgenmsg));
+    rt->rtgen_family = af_family;
+
+    rc = 0;
+
+    nl = mnl_socket_open(NETLINK_ROUTE);
+    if (nl == NULL)
+    {
+        log_message(LOG_ERR," mnl_socket_open failed: %s", strerror(errno));
+        goto error;
+    }
+
+    if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0)
+    {
+        log_message(LOG_ERR, "Failed to bind mnl socket: %s",strerror(errno));
+        goto error;
+    }
+
+    portid = mnl_socket_get_portid(nl);
+
+    if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0)
+    {
+        log_message(LOG_ERR,"mnl_socket_sendto failed: %s",strerror(errno));
+        goto error;
+    }
+
+    while ((ret = mnl_socket_recvfrom(nl, buf, sizeof(buf))) > 0)
+    {
+        ret = mnl_cb_run(buf, ret, seq, portid, util_neigh_cb, NULL);
+        if (ret <= MNL_CB_STOP)
+            break;
+    }
+
+    rc = 1;
+
+error:
+    if (nl) mnl_socket_close(nl);
+    return rc;
+}
+
+/**
+ * @brief ev callback to neighbor events
+ */
+static void read_mnl_neigh_cb(void)
+{
+    char rcv_buf[MNL_SOCKET_BUFFER_SIZE];
+    struct nf_neigh_context *ctxt;
+    int portid;
+    int ret;
+
+    ctxt = nf_neigh_get_context();
+
+    ret = mnl_socket_recvfrom(ctxt->neigh_mnl, rcv_buf, sizeof(rcv_buf));
+    if (ret == -1)
+    {
+        log_message(LOG_ERR," mnl_socket_recvfrom failed: %s\n", strerror(errno));
+        return;
+    }
+
+    portid = mnl_socket_get_portid(ctxt->neigh_mnl);
+    ret = mnl_cb_run(rcv_buf, ret, 0, portid, util_neigh_cb, NULL);
+
+    if (ret == -1) log_message(LOG_ERR," mnl_cb_run failed");
+}
+
+void *neigh_main_loop(void *data)
+{
+    struct nf_neigh_context *ctxt = data;
+
+    /* Cache the current arp table.*/
+    nf_util_dump_neighs(AF_INET);
+    nf_util_dump_neighs(AF_INET6);
+
+    while (!ctxt->quit)
+    {
+        read_mnl_neigh_cb();
+    }
+    return NULL;
+}
+
+int nf_neigh_event_init(void)
+{
+    struct nf_neigh_context *ctxt;
+    struct mnl_socket *nl;
+    int group;
+    int ret;
+
+    ctxt = nf_neigh_get_context();
+
+    if (ctxt->neigh_cb == NULL) return 0;
+
+    nl = mnl_socket_open(NETLINK_ROUTE);
+    if (nl == NULL)
+    {
+        log_message(LOG_ERR," mnl_socket_open failed: %s", strerror(errno));
+        return -1;
+    }
+
+    ret = mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID);
+    if (ret < 0)
+    {
+        log_message(LOG_ERR," mnl_socket_bind failed: %s", strerror(errno));
+        return -1;
+    }
+
+    group = RTNLGRP_NEIGH;
+    ret = mnl_socket_setsockopt(nl, NETLINK_ADD_MEMBERSHIP, &group,
+                                sizeof(int));
+    if (ret < 0)
+    {
+        log_message(LOG_ERR," mnl_socket_setsockopt failed: %s", strerror(errno));
+        return -1;
+    }
+
+    ctxt->neigh_mnl = nl;
+    ctxt->neigh_fd = mnl_socket_get_fd(nl);
+    log_message(LOG_INFO," nf_neigh_context initialized");
+
+    return 0;
+}
+
+int nf_neigh_init(void)
+{
+    struct nf_neigh_context *ctxt;
+    int ret;
+
+    ctxt = nf_neigh_get_context();
+    memset(ctxt, 0, sizeof(*ctxt));
+
+    ctxt->neigh_cb = process_neigh_event;
+    pthread_mutex_init(&ctxt->arptable_lock, NULL);
+    ctxt->arptable = hashmap_create(ARP_BUCKETS);
+
+    if (ctxt->arptable == NULL)
+    {
+        log_message(LOG_ERR," neighbor event: couldn't get hash map");
+        goto err;
+    }
+
+
+    ret = nf_neigh_event_init();
+    if (ret)
+    {
+        log_message(LOG_ERR," neighbor event init failure");
+        goto err;
+    }
+
+    return 0;
+
+err:
+    hashmap_delete(ctxt->arptable);
+    return -1;
+}
+
+int nf_neigh_exit(void)
+{
+    struct nf_neigh_context *ctxt;
+
+    ctxt = nf_neigh_get_context();
+
+    ctxt->quit = 1;
+    mnl_socket_close(ctxt->neigh_mnl);
+
+    hashmap_delete(ctxt->arptable);
+    return 0;
+}
diff --git a/src/nf_util_neigh.h b/src/nf_util_neigh.h
new file mode 100644
index 0000000..f8183bb
--- /dev/null
+++ b/src/nf_util_neigh.h
@@ -0,0 +1,58 @@
+#ifndef NF_UTILS_H_INCLUDED
+#define NF_UTILS_H_INCLUDED
+
+#include <arpa/inet.h>
+
+#define PRI_macaddr_t  "%02x:%02x:%02x:%02x:%02x:%02x"
+
+#define FMT_macaddr_t(x)     (x).addr[0], (x).addr[1], (x).addr[2], (x).addr[3], (x).add    r[4], (x).addr[5]
+#define FMT_macaddr_pt(x)    (x)->addr[0], (x)->addr[1], (x)->addr[2], (x)->addr[3], (x)    ->addr[4],(x)->addr[5]
+#define MAX_MAC_STR_SIZE 18
+
+typedef struct { uint8_t addr[6]; } macaddr_t;
+
+struct nf_neigh_info
+{
+    int  af_family;
+    void *ipaddr;
+    void *hwaddr;
+    unsigned int   add;
+    unsigned int   del;
+
+};
+
+typedef void (*process_nl_event_cb)(struct nf_neigh_info *neigh_info);
+
+typedef struct nf_neigh_context
+{
+    pthread_t neigh_thread;
+
+    struct mnl_socket *neigh_mnl;
+    process_nl_event_cb neigh_cb;
+    int neigh_fd;
+    unsigned int quit;
+
+    hashmap_t arptable;
+    pthread_mutex_t arptable_lock;
+} nf_neigh_context;
+
+
+void *neigh_main_loop(void *data);
+
+struct nf_neigh_context *nf_neigh_get_context(void);
+
+unsigned int nf_util_dump_neighs(int af_family);
+
+unsigned int nf_neigh_get_mac(const char *ip, char *mac);
+
+int nf_neigh_event_init(void);
+
+int neigh_add_to_map(struct nf_neigh_info *neigh_info);
+
+int neigh_del_from_map(struct nf_neigh_info *neigh_info);
+
+int nf_neigh_init(void);
+
+int nf_neigh_exit(void);
+
+#endif /* NF_UTILS_H_INCLUDED */
diff --git a/src/reqs.c b/src/reqs.c
index 041fb03..610d286 100644
--- a/src/reqs.c
+++ b/src/reqs.c
@@ -590,6 +590,20 @@ static int add_xtinyproxy_header (struct conn_s *connptr)
 }
 #endif /* XTINYPROXY */
 
+#ifdef XTINYPROXYMAC_ENABLE
+/*
+ * Add the X-Tinyproxy-MAC header to the collection of headers being sent to
+ * the server.
+ */
+static int add_xtinyproxymac_header (struct conn_s *connptr)
+{
+        assert (connptr && connptr->server_fd >= 0);
+        return write_message (connptr->server_fd,
+                              "X-Tinyproxy-MAC: %s\r\n", connptr->client_mac_addr);
+}
+#endif /* XTINYPROXYMAC */
+
+
 /*
  * Take a complete header line and break it apart (into a key and the data.)
  * Now insert this information into the hashmap for the connection so it
@@ -941,6 +955,11 @@ process_client_headers (struct conn_s *connptr, hashmap_t hashofheaders)
         if (config->add_xtinyproxy)
                 add_xtinyproxy_header (connptr);
 #endif
+#if defined(XTINYPROXYMAC_ENABLE)
+        if (config->add_xtinyproxymac)
+		add_xtinyproxymac_header (connptr);
+#endif
+
 
         /* Write the final "blank" line to signify the end of the headers */
         if (safe_write (connptr->server_fd, "\r\n", 2) < 0)

