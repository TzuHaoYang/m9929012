Fix for ipv6 dhcpv6 frame release

--- a/src/dhcpv6.c
+++ b/src/dhcpv6.c
@@ -108,6 +108,15 @@
 // client options
 static unsigned int client_options = 0;
 
+// For Test
+static bool IA_NA_CHECK = false;
+
+bool get_ia_na_checke ()
+{
+	syslog(LOG_NOTICE, "***** [%s] start",__func__);
+	syslog(LOG_NOTICE, "IA_NA_CHECK: %d", IA_NA_CHECK);
+	return IA_NA_CHECK;
+}
 
 int init_dhcpv6(const char *ifname, unsigned int options, int sol_timeout)
 {
@@ -515,6 +524,7 @@
 
 int dhcpv6_request(enum dhcpv6_msg type)
 {
+	// syslog(LOG_NOTICE, "***** [%s] start and dhcpv6 msg type: %d",__func__, type);
 	uint8_t rc = 0;
 	uint64_t timeout = UINT32_MAX;
 	struct dhcpv6_retx *retx = &dhcpv6_retx[type];
@@ -532,8 +542,13 @@
 	else if (type == DHCPV6_MSG_REBIND)
 		timeout = (t3 > t2) ? t3 - t2 : ((t2 == UINT32_MAX) ? UINT32_MAX : 0);
 
-	if (timeout == 0)
+	// syslog(LOG_NOTICE, "***** [%s] t1: %lld, t2: %lld, t3: %lld",__func__, t1, t2 ,t3);
+	// syslog(LOG_NOTICE, "***** timeout: %lld\n",timeout);
+
+	if (timeout == 0) {
+		syslog(LOG_NOTICE, "***** [%s] return: -1\n",__func__);
 		return -1;
+	}
 
 	syslog(LOG_NOTICE, "Starting %s transaction (timeout %llus, max rc %d)",
 			retx->name, (unsigned long long)timeout, retx->max_rc);
@@ -599,8 +614,10 @@
 
 
 			// Check for pending signal
-			if (odhcp6c_signal_process())
+			if (odhcp6c_signal_process()) {
+				syslog(LOG_NOTICE, "***** [%s] return: -1\n",__func__);
 				return -1;
+			}
 
 			// Set timeout for receiving
 			uint64_t t = round_end - round_start;
@@ -608,8 +625,10 @@
 			setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO,
 					&tv, sizeof(tv));
 
+			// syslog(LOG_NOTICE, "***** before recvmsg");
 			// Receive cycle
 			len = recvmsg(sock, &msg, 0);
+			// syslog(LOG_NOTICE, "***** after recvmsg: %d", len);
 			if (len < 0)
 				continue;
 
@@ -629,6 +648,8 @@
 
 			if (!dhcpv6_response_is_valid(buf, len, trid,
 							type, &pktinfo->ipi6_addr)) {
+				// add Meassage
+				syslog(LOG_NOTICE, "***** !dhcpv6_response_is_valid");
 				len = -1;
 				continue;
 			}
@@ -641,8 +662,12 @@
 			syslog(LOG_NOTICE, "Got a valid reply after "
 					"%llums", (unsigned long long)elapsed);
 
-			if (retx->handler_reply)
+			if (retx->handler_reply) {
+				// add Message
+				syslog(LOG_NOTICE, "***** retx->handler_reply");
 				len = retx->handler_reply(type, rc, opt, opt_end, &addr);
+				syslog(LOG_NOTICE, "***** retx->handler_reply ret =%d", len);
+			}
 
 			if (len > 0 && round_end - round_start > 1000)
 				round_end = 1000 + round_start;
@@ -651,8 +676,10 @@
 		// Allow
 		if (retx->handler_finish)
 			len = retx->handler_finish();
+
 	} while (len < 0 && ((timeout == UINT32_MAX) || (elapsed / 1000 < timeout)) && 
 			(!retx->max_rc || rc < retx->max_rc));
+	syslog(LOG_NOTICE, "***** [%s] return: %d\n",__func__, len);
 	return len;
 }
 
@@ -661,6 +688,7 @@
 		const uint8_t transaction[3], enum dhcpv6_msg type,
 		const struct in6_addr *daddr)
 {
+	syslog(LOG_NOTICE, "***** [%s] start", __func__);
 	const struct dhcpv6_header *rep = buf;
 	if (len < (ssize_t)sizeof(*rep) || memcmp(rep->tr_id,
 			transaction, sizeof(rep->tr_id)))
@@ -736,10 +764,14 @@
 			ia_present = true;
 			if (olen < -4 + sizeof(struct dhcpv6_ia_hdr))
 				options_valid = false;
+			// add Meassage otype check
+			syslog(LOG_NOTICE, "***** otype: %d, options_valid%d ",otype, options_valid);
 		}
 		else if ((otype == DHCPV6_OPT_IA_ADDR) || (otype == DHCPV6_OPT_IA_PREFIX) ||
 				(otype == DHCPV6_OPT_PD_EXCLUDE)) {
 			// Options are not allowed on global level
+			// add Message
+			syslog(LOG_NOTICE, "***** (otype == DHCPV6_OPT_IA_ADDR) || (otype == DHCPV6_OPT_IA_PREFIX) || (otype == DHCPV6_OPT_PD_EXCLUDE)");
 			options_valid = false;
 		}
 	}
@@ -763,6 +795,7 @@
 
 int dhcpv6_poll_reconfigure(void)
 {
+	// syslog(LOG_NOTICE, "***** [%s] start",__func__);
 	int ret = dhcpv6_request(DHCPV6_MSG_UNKNOWN);
 	if (ret != -1)
 		ret = dhcpv6_request(ret);
@@ -844,7 +877,7 @@
 					have_na = true;
 		}
 	}
-
+	// syslog(LOG_NOTICE, "have_na: %d, na_mode %d",have_na, na_mode);
 	if ((!have_na && na_mode == IA_MODE_FORCE) ||
 			(!have_pd && pd_mode == IA_MODE_FORCE)) {
 		/*
@@ -899,6 +932,7 @@
 static int dhcpv6_handle_reply(enum dhcpv6_msg orig, _unused const int rc,
 		const void *opt, const void *end, const struct sockaddr_in6 *from)
 {
+	syslog(LOG_NOTICE, "***** [%s] start",__func__);
 	uint8_t *odata;
 	uint16_t otype, olen;
 	uint32_t refresh = 86400;
@@ -977,12 +1011,19 @@
 				// Get and handle status code
 				dhcpv6_for_each_option(&ia_hdr[1], odata + olen,
 						stype, slen, sdata) {
+					syslog(LOG_NOTICE, "***** stype: %d",stype);
+					if (stype == DHCPV6_OPT_IA_ADDR)
+						IA_NA_CHECK = true;
+
+
 					if (stype == DHCPV6_OPT_STATUS && slen >= 2) {
 						uint8_t *mdata = (slen > 2) ? &sdata[2] : NULL;
 						uint16_t mlen = (slen > 2) ? slen - 2 : 0;
 
 						code = ((int)sdata[0]) << 8 | ((int)sdata[1]);
 
+
+						
 						if (code == DHCPV6_Success)
 							continue;
 
@@ -994,10 +1035,17 @@
 							return ret;
 						break;
 					}
+					else if (stype == DHCPV6_OPT_IA_ADDR)
+					{
+
+					}
 				}
 
-				if (code != DHCPV6_Success)
+				if (code != DHCPV6_Success) {
+					// syslog(LOG_NOTICE, "***** otype: %d, IA_NA_CHECK: %d", otype, IA_NA_CHECK);
+					// if (otype == DHCPV6_OPT_IA_NA) IA_NA_CHECK = false;
 					continue;
+				}
 
 				dhcpv6_parse_ia(ia_hdr, odata + olen + sizeof(*ia_hdr));
 				passthru = false;
@@ -1147,6 +1195,7 @@
 
 static int dhcpv6_parse_ia(void *opt, void *end)
 {
+	syslog(LOG_NOTICE, "***** [%s] start",__func__);
 	struct dhcpv6_ia_hdr *ia_hdr = (struct dhcpv6_ia_hdr *)opt;
 	int parsed_ia = 0;
 	uint32_t t1, t2;
@@ -1167,9 +1216,18 @@
 		entry.iaid = ia_hdr->iaid;
 
 		if (otype == DHCPV6_OPT_IA_PREFIX) {
+			int len =0;
 			struct dhcpv6_ia_prefix *prefix = (void*)&odata[-4];
-			if (olen + 4U < sizeof(*prefix))
+			if (olen + 4U < sizeof(*prefix)) {
 				continue;
+			}
+            len = ntohs(prefix->len);
+			syslog(LOG_NOTICE, "prefix->len %d , header_len %d ", len + 4U, sizeof(*prefix));
+            if (len + 4U < sizeof(*prefix)) {
+				syslog(LOG_NOTICE, "********** bypass DHCPV6_OPT_IA_PREFIX ");
+				continue;
+			}
+
 
 			entry.valid = ntohl(prefix->valid);
 			entry.preferred = ntohl(prefix->preferred);
--- a/src/odhcp6c.c
+++ b/src/odhcp6c.c
@@ -308,9 +308,9 @@
 
 		if (mode < 0)
 			continue;
-
+		int res;
 		do {
-			int res = dhcpv6_request(mode == DHCPV6_STATELESS ?
+			res = dhcpv6_request(mode == DHCPV6_STATELESS ?
 					DHCPV6_MSG_INFO_REQ : DHCPV6_MSG_REQUEST);
 			bool signalled = odhcp6c_signal_process();
 
@@ -324,8 +324,13 @@
 			mode = dhcpv6_promote_server_cand();
 		} while (mode > DHCPV6_UNKNOWN);
 
-		if (mode < 0)
+		
+		// if (mode == DHCPV6_STATEFUL && res == 100){
+		// 	goto EXPIRED;
+		// }
+		if (mode < 0){
 			continue;
+		}
 
 		switch (mode) {
 		case DHCPV6_STATELESS:
@@ -363,13 +368,21 @@
 			script_call("bound", script_sync_delay, true);
 			syslog(LOG_NOTICE, "entering stateful-mode on %s", ifname);
 
+			if (!get_ia_na_checke()){
+				signal_term =1;
+				goto EXPIRED;
+			}
 			while (!signal_usr2 && !signal_term) {
 				// Renew Cycle
 				// Wait for T1 to expire or until we get a reconfigure
+				// syslog(LOG_NOTICE, "***** 1st\n");
 				int res = dhcpv6_poll_reconfigure();
+				// syslog(LOG_NOTICE, "***** 1-1 st and res: %d\n", res);
 				odhcp6c_signal_process();
+				// syslog(LOG_NOTICE, "***** 1-2 st and res: %d\n", res);
 				if (res > 0) {
 					script_call("updated", 0, false);
+					// syslog(LOG_NOTICE, "***** 2nd\n");
 					continue;
 				}
 
@@ -377,14 +390,16 @@
 				if (signal_usr1)
 					signal_usr1 = false; // Acknowledged
 				if (signal_usr2 || signal_term)
-					break; // Other signal type
+					break; // Other signal typef
 
 				// Send renew as T1 expired
 				res = dhcpv6_request(DHCPV6_MSG_RENEW);
 				odhcp6c_signal_process();
+				// syslog(LOG_NOTICE, "***** 3rd\n");
 				if (res > 0) { // Renew was succesfull
 					// Publish updates
 					script_call("updated", 0, false);
+					// syslog(LOG_NOTICE, "***** 4th\n");
 					continue; // Renew was successful
 				}
 
@@ -395,6 +410,7 @@
 				odhcp6c_get_state(STATE_IA_PD, &ia_pd_len);
 				odhcp6c_get_state(STATE_IA_NA, &ia_na_len);
 
+				// syslog(LOG_NOTICE, "***** ia_pd_len: %d, ia_na_len: %d\n", ia_pd_len, ia_na_len);
 				if (ia_pd_len == 0 && ia_na_len == 0)
 					break;
 
@@ -414,6 +430,8 @@
 			break;
 		}
 
+EXPIRED :
+		syslog(LOG_NOTICE, "***** odhcp6c expire\n");
 		odhcp6c_expire();
 
 		size_t ia_pd_len, ia_na_len, server_id_len;
@@ -425,6 +443,7 @@
 		bound = false;
 		script_call("unbound", 0, true);
 
+		// syslog(LOG_NOTICE, "***** release: %d, ia_pd_len: %d, ia_na_len: %d, server_id_len:%d\n", release, ia_pd_len, ia_na_len, server_id_len);
 		if (server_id_len > 0 && (ia_pd_len > 0 || ia_na_len > 0) && release)
 			dhcpv6_request(DHCPV6_MSG_RELEASE);
 
@@ -499,6 +518,8 @@
 
 bool odhcp6c_signal_process(void)
 {
+	// syslog(LOG_NOTICE, "***** [%s] start",__func__);
+	// syslog(LOG_NOTICE, "***** \tsignal_io: %d", signal_io);
 	while (signal_io) {
 		signal_io = false;
 
@@ -515,7 +536,7 @@
 			ra = true;
 		}
 	}
-
+	// syslog(LOG_NOTICE, "***** \tsignal_usr1: %d, signal_usr2: %d, signal_term: %d", signal_usr1, signal_usr2,signal_term);
 	return signal_usr1 || signal_usr2 || signal_term;
 }
 
--- a/src/odhcp6c.h
+++ b/src/odhcp6c.h
@@ -314,6 +314,8 @@
 int dhcpv6_request(enum dhcpv6_msg type);
 int dhcpv6_poll_reconfigure(void);
 int dhcpv6_promote_server_cand(void);
+// TEST
+bool get_ia_na_checke ();
 
 int init_rtnetlink(void);
 int set_rtnetlink_addr(int ifindex, const struct in6_addr *addr,
