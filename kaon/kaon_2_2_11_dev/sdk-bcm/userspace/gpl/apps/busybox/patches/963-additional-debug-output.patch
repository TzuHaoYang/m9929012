--- a/networking/udhcp/dhcpc.c
+++ b/networking/udhcp/dhcpc.c
@@ -34,6 +34,7 @@
 #include <netinet/if_ether.h>
 #include <linux/filter.h>
 #include <linux/if_packet.h>
+#include <netinet/ether.h>
 
 #ifndef PACKET_AUXDATA
 # define PACKET_AUXDATA 8
@@ -1280,6 +1281,9 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 	client_config.script = CONFIG_UDHCPC_DEFAULT_SCRIPT;
 	str_V = "udhcp "BB_VER;
 
+	/* CHECKME: Q'n'D temporary workaround, hardcode verbosity level [ESW-1836] */
+	dhcp_verbose = 1;
+
 	/* Parse command line */
 	opt = getopt32long(argv, "^"
 		/* O,x: list; -T,-t,-A take numeric param */
@@ -1457,6 +1461,8 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		 * resend discover/renew/whatever
 		 */
 		if (retval == 0) {
+			int last_client_config_ifindex = client_config.ifindex;
+
 			/* When running on a bridge, the ifindex may have changed
 			 * (e.g. if member interfaces were added/removed
 			 * or if the status of the bridge changed).
@@ -1469,6 +1475,21 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 			) {
 				goto ret0; /* iface is gone? */
 			}
+
+			if (client_config.ifindex != last_client_config_ifindex) {
+				log1("ifindex changed: was %d, now %d", last_client_config_ifindex, client_config.ifindex);
+			}
+			if (clientid_mac_ptr == NULL) {
+				log1("clientid_mac_ptr is NULL");
+			} else {
+				if (memcmp(clientid_mac_ptr, client_config.client_mac, 6) != 0) {
+					log1("client_mac changed: was %s, now %s",
+						ether_ntoa(clientid_mac_ptr), ether_ntoa((void *)client_config.client_mac)
+					);
+				}
+			}
+			log1("proceeding with ifindex %d and client_mac %s", client_config.ifindex, ether_ntoa((void *)client_config.client_mac));
+
 			if (clientid_mac_ptr)
 				memcpy(clientid_mac_ptr, client_config.client_mac, 6);
 
