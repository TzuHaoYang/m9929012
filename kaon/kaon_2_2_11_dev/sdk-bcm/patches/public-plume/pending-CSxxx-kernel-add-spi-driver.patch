I'm not sure if this was authored by Matej Anzin
or if this was dropped by broadcom and he
integrated & bugfixed it -- Michal

2019-09-05: I think this was dropped by Broadcom
because it has their License intro in
spi_bcmgpio.c. I just can't find how we got that -
either JIRA or CSP ticket or email.

This is related to CYR-26 / ESW-36.
--- a/bcmdrivers/Makefile
+++ b/bcmdrivers/Makefile
@@ -144,6 +144,7 @@ $(eval $(call LN_RULE, $(CONFIG_BCM_SERI
 $(eval $(call LN_RULE, $(CONFIG_BCM_EXT_TIMER), opensource/char/timer, $(LN_NAME), $(CONFIG_BCM_EXT_TIMER_IMPL)))
 $(eval $(call LN_RULE, $(CONFIG_BCM_I2C_BUS), opensource/char/i2c/busses, $(LN_NAME), $(CONFIG_BCM_I2C_BUS_IMPL)))
 $(eval $(call LN_RULE, $(CONFIG_BCM_I2C_CHIP), opensource/char/i2c/chips, $(LN_NAME), $(CONFIG_BCM_I2C_CHIP_IMPL)))
+$(eval $(call LN_RULE, $(CONFIG_BCM_SPI_BUS), opensource/char/spi/busses, $(LN_NAME), $(CONFIG_BCM_SPI_BUS_IMPL)))
 $(eval $(call LN_RULE, $(CONFIG_BCM_PLATFORM), opensource/char/plat-bcm, $(LN_NAME), $(CONFIG_BCM_PLATFORM_IMPL)))
 $(eval $(call LN_RULE, $(CONFIG_BCM_OPTICALDET), opensource/char/opticaldet, $(LN_NAME), $(CONFIG_BCM_OPTICALDET_IMPL)))
 $(eval $(call LN_RULE, $(CONFIG_BCM_WANTYPEDET), opensource/char/wantypedet, $(LN_NAME), $(CONFIG_BCM_WANTYPEDET_IMPL)))
--- a/hostTools/scripts/gendefconfig.d/10kernel.conf
+++ b/hostTools/scripts/gendefconfig.d/10kernel.conf
@@ -44,6 +44,11 @@ if ( $p->get('BUILD_DEBUG_TOOLS') ) {
     $c->set( 'CONFIG_DEBUG_FS',      'y' );
 }
 
+if ( $p->get('BRCM_DRIVER_SPI') ) {
+    $c->set( 'CONFIG_SPI_MASTER',			'y');
+    $c->set( 'CONFIG_SPI_BITBANG',			'y');
+}
+
 $c->set( 'CONFIG_BRCM_IKOS',   $p->get('BRCM_IKOS') );
 $c->set( 'CONFIG_BCM_ANDROID', $p->get('BRCM_ANDROID') );
 
--- a/hostTools/scripts/gendefconfig.d/15general.conf
+++ b/hostTools/scripts/gendefconfig.d/15general.conf
@@ -201,6 +201,18 @@ if ( $chip =~ /^(47189)$/ ) {
     }
 }
 
+if ( $chip =~ /^(47189)$/ ) {
+    $c->driver_setup( "SPI", "SPI_BUS" );
+
+    if ( $p->get("BRCM_DRIVER_SPI") ) {
+        $c->set( "CONFIG_GPIOLIB",     "y" );
+        $c->set( "CONFIG_SPI_SPIDEV",  "y" );
+        $c->set( "CONFIG_SPI",         "y" );
+        $c->set( "CONFIG_SPI_GPIO",    "y" );
+        $c->set( "CONFIG_SPI_DEBUG",   "y" );
+    }
+}
+
 if ( $chip =~ /^(6858|6856|6846|6878)$/ ) {
     if ( $p->get( "BRCM_PON_WAN_TYPE_AUTO_DETECT" ) ) {
         $c->set( "CONFIG_BCM_PON_WAN_TYPE_AUTO_DETECT", "y" );
--- a/kernel/linux-4.1/Kconfig.bcm
+++ b/kernel/linux-4.1/Kconfig.bcm
@@ -665,6 +665,11 @@ config BCM_I2S_IMPL
 	int "Implementation index for I2S module"
 	depends on BCM_I2S
 
+config BCM_SPI_BUS_IMPL
+	int "Implementation index for SPI Bus module"
+	depends on BCM_SPI_BUS
+
+
 config BCM_LASER
 	tristate "Support for LASER"
 
@@ -716,6 +721,9 @@ config BCM_I2C_GPIO
 config BCM_I2C_CHIP
 	tristate "Support for I2C Chip Drivers"
 
+config BCM_SPI_BUS
+	tristate "Support for SPI Bus Drivers"
+
 config BCM_I2S
 	tristate "Support for I2S Drivers"
 
--- a/targets/config.in
+++ b/targets/config.in
@@ -449,6 +449,8 @@ if [ "$BRCM_47189" = "y" ]; then
    tristate 'I2C' BRCM_DRIVER_I2C
 fi
 
+bool "Bitbang SPI master" BRCM_DRIVER_SPI
+
 if [ "$BRCM_6858" = "y" -o "$BRCM_6856" = "y" -o "$BRCM_6846" = "y" -o "$BRCM_6878" = "y" ]; then
    define_string BRCM_PON_WAN_TYPE_AUTO_DETECT "y"
 fi
--- /dev/null
+++ b/bcmdrivers/opensource/char/spi/busses/impl1/Makefile
@@ -0,0 +1,15 @@
+# File: bcmdrivers/broadcom/char/i2c/busses/Makefile
+#
+# Makefile for the BCM6816 I2C Adapter+Algorithm driver.
+#
+
+obj-$(CONFIG_BCM_I2C_GPIO) += spi_bcmgpio.o
+
+EXTRA_CFLAGS += -I$(INC_BRCMDRIVER_PUB_PATH)/$(BRCM_BOARD)
+EXTRA_CFLAGS += -I$(INC_BRCMBOARDPARMS_PATH)/$(BRCM_BOARD)
+EXTRA_CFLAGS += -I$(INC_BRCMSHARED_PUB_PATH)/$(BRCM_BOARD)
+EXTRA_CFLAGS += -Werror
+ 
+clean:
+	rm -f core *.o *.a *.s .*.cmd *.ko
+
--- /dev/null
+++ b/bcmdrivers/opensource/char/spi/busses/impl1/spi_bcmgpio.c
@@ -0,0 +1,142 @@
+/*
+* <:copyright-BRCM:2016:DUAL/GPL:standard
+*
+*    Copyright (c) 2016 Broadcom
+*    All Rights Reserved
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed
+* to you under the terms of the GNU General Public License version 2
+* (the "GPL"), available at http://www.broadcom.com/licenses/GPLv2.php,
+* with the following added to such license:
+*
+*    As a special exception, the copyright holders of this software give
+*    you permission to link this software with independent modules, and
+*    to copy and distribute the resulting executable under terms of your
+*    choice, provided that you also meet, for each linked independent
+*    module, the terms and conditions of the license of that module.
+*    An independent module is a module which is not derived from this
+*    software.  The special exception does not apply to any modifications
+*    of the software.
+*
+* Not withstanding the above, under no circumstances may you combine
+* this software in any way with any other Broadcom software provided
+* under a license other than the GPL, without Broadcom's express prior
+* written consent.
+*
+* :>
+*/
+
+/*
+ *******************************************************************************
+ * File Name  : spi_bcmgpio.c
+ *
+ * Description: This file contains Broadcom spi gpio device driver using Linux
+ *              spi Bit-Bang driver.
+ *
+ *******************************************************************************
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_gpio.h>
+#include <linux/gpio.h>
+
+#include <bcm_gpio.h>
+#include <board.h>
+#include <linux/platform_device.h>
+
+/****************************************************************************
+ * If CONFIG_SPI_GPIO is defined, the kernel SPI gpio driver,
+ * kernel/linux/drivers/spi/busses/spi-gpio.c, is compiled into the image.
+ * Register a device with it.
+ *
+ ****************************************************************************/
+
+static struct spi_board_info spi_board_info[] __initdata = {
+    {
+        .modalias = "spidev",
+        .max_speed_hz = 1000000,     /* max spi clock (SCK) speed in HZ */
+        .bus_num = 0,
+        .chip_select = 0,
+        .mode = SPI_MODE_0,
+    },
+};
+
+static struct spi_gpio_platform_data bcm_spi_gpio_platform_data;
+
+
+static struct platform_device bcm_spi_gpio = {
+    .name      = "spi_gpio",
+    .id        = 0,
+    .dev       = {
+        .platform_data= &bcm_spi_gpio_platform_data
+    },
+};
+
+static struct platform_device *bcm_spi_devices[] __initdata = {
+    &bcm_spi_gpio,
+};
+
+
+static int __init spi_bcm_gpio_init(void)
+{
+    unsigned short bpGpio_miso, bpGpio_mosi, bpGpio_sclk, bpGpio_cs;
+    int cs;
+    int ret;
+
+    BpGetSpiClkGpio( &bpGpio_sclk );
+    BpGetSpiCsGpio( &bpGpio_cs );
+    BpGetSpiMisoGpio( &bpGpio_miso );
+    BpGetSpiMosiGpio( &bpGpio_mosi );
+
+    if (bpGpio_sclk != BP_NOT_DEFINED &&
+        bpGpio_cs != BP_NOT_DEFINED &&
+        bpGpio_miso != BP_NOT_DEFINED &&
+        bpGpio_mosi != BP_NOT_DEFINED) 
+    {
+        bcm_spi_gpio_platform_data.sck = bpGpio_sclk;
+        bcm_spi_gpio_platform_data.mosi = bpGpio_mosi;
+        bcm_spi_gpio_platform_data.miso = bpGpio_miso;
+        bcm_spi_gpio_platform_data.num_chipselect = 1;
+ 
+        printk("spi_bcm_gpio_init: SCK=%u and MOSI=%lu MISO=%lu\n",
+                  bcm_spi_gpio_platform_data.sck, 
+                  bcm_spi_gpio_platform_data.mosi,
+                  bcm_spi_gpio_platform_data.miso);
+
+        cs = bpGpio_cs;
+        spi_board_info[0].controller_data = (void *)cs;
+        
+        ret = spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
+        printk("spi_bcm_gpio_init register spidev status=%d\n", ret);
+        
+        if (ret != 0)
+        {
+            return ret;
+        }
+
+        ret = platform_add_devices(bcm_spi_devices, ARRAY_SIZE(bcm_spi_devices));
+        printk("spi_bcm_gpio_init registering SPI driver status=%d\n", ret);
+
+    }
+    else
+    {
+        printk("spi_bcm_gpio_init: GPIO pins undefined\n");
+        ret = 1;
+    }
+
+    return ret; /* successful */
+}
+arch_initcall(spi_bcm_gpio_init);
+
+static void __exit spi_bcm_gpio_exit(void)
+{
+}
+module_exit(spi_bcm_gpio_exit);
+
+MODULE_DESCRIPTION("Broadcom SPI GPIO driver");
+MODULE_LICENSE("GPL");
--- a/kernel/linux-4.1/drivers/spi/spi-bitbang.c
+++ b/kernel/linux-4.1/drivers/spi/spi-bitbang.c
@@ -64,7 +64,7 @@ static unsigned bitbang_txrx_8(
 	unsigned		ns,
 	struct spi_transfer	*t
 ) {
-	unsigned		bits = t->bits_per_word;
+	unsigned		bits = (t->bits_per_word > 0 ? t->bits_per_word : spi->bits_per_word);
 	unsigned		count = t->len;
 	const u8		*tx = t->tx_buf;
 	u8			*rx = t->rx_buf;
@@ -90,7 +90,7 @@ static unsigned bitbang_txrx_16(
 	unsigned		ns,
 	struct spi_transfer	*t
 ) {
-	unsigned		bits = t->bits_per_word;
+	unsigned		bits = (t->bits_per_word > 0 ? t->bits_per_word : spi->bits_per_word);
 	unsigned		count = t->len;
 	const u16		*tx = t->tx_buf;
 	u16			*rx = t->rx_buf;
@@ -116,7 +116,7 @@ static unsigned bitbang_txrx_32(
 	unsigned		ns,
 	struct spi_transfer	*t
 ) {
-	unsigned		bits = t->bits_per_word;
+	unsigned		bits = (t->bits_per_word > 0 ? t->bits_per_word : spi->bits_per_word);
 	unsigned		count = t->len;
 	const u32		*tx = t->tx_buf;
 	u32			*rx = t->rx_buf;
--- a/hostTools/scripts/defconfig-bcm.template
+++ b/hostTools/scripts/defconfig-bcm.template
@@ -966,6 +966,7 @@ CONFIG_MODULE_UNLOAD=y
 # CONFIG_BCM947189_LTE_IMPL=1
 # CONFIG_BCM947189_I2C_BUS_IMPL=1
 # CONFIG_BCM947189_I2C_CHIP_IMPL=1
+# CONFIG_BCM947189_SPI_BUS_IMPL=1
 # CONFIG_BCM947189_SPU_IMPL=3
 # CONFIG_BCM947189_PLATFORM_IMPL=1
 # CONFIG_BCM947189_MoCA_IMPL=2
