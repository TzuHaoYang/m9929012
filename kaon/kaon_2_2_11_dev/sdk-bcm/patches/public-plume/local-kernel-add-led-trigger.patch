--- a/kernel/linux-4.1/drivers/leds/leds-pwm.c
+++ b/kernel/linux-4.1/drivers/leds/leds-pwm.c
@@ -97,7 +97,8 @@ static void led_pwm_cleanup(struct led_p
 }
 
 static int led_pwm_add(struct device *dev, struct led_pwm_priv *priv,
-		       struct led_pwm *led, struct device_node *child)
+		       struct led_pwm *led, struct device_node *child,
+		       int brightness)
 {
 	struct led_pwm_data *led_data = &priv->leds[priv->num_leds];
 	int ret;
@@ -106,7 +107,7 @@ static int led_pwm_add(struct device *de
 	led_data->cdev.name = led->name;
 	led_data->cdev.default_trigger = led->default_trigger;
 	led_data->cdev.brightness_set = led_pwm_set;
-	led_data->cdev.brightness = LED_OFF;
+	led_data->cdev.brightness = brightness;
 	led_data->cdev.max_brightness = led->max_brightness;
 	led_data->cdev.flags = LED_CORE_SUSPENDRESUME;
 
@@ -145,6 +146,7 @@ static int led_pwm_create_of(struct devi
 	struct device_node *child;
 	struct led_pwm led;
 	int ret = 0;
+	int brightness = LED_OFF;
 
 	memset(&led, 0, sizeof(led));
 
@@ -157,8 +159,9 @@ static int led_pwm_create_of(struct devi
 		led.active_low = of_property_read_bool(child, "active-low");
 		of_property_read_u32(child, "max-brightness",
 				     &led.max_brightness);
+		of_property_read_u32(child, "default-brightness", &brightness);
 
-		ret = led_pwm_add(dev, priv, &led, child);
+		ret = led_pwm_add(dev, priv, &led, child, brightness);
 		if (ret) {
 			of_node_put(child);
 			break;
@@ -191,7 +194,7 @@ static int led_pwm_probe(struct platform
 	if (pdata) {
 		for (i = 0; i < count; i++) {
 			ret = led_pwm_add(&pdev->dev, priv, &pdata->leds[i],
-					  NULL);
+					  NULL, LED_OFF);
 			if (ret)
 				break;
 		}
--- a/kernel/linux-4.1/drivers/leds/trigger/Kconfig
+++ b/kernel/linux-4.1/drivers/leds/trigger/Kconfig
@@ -59,6 +59,35 @@ config LEDS_TRIGGER_BACKLIGHT
 
 	  If unsure, say N.
 
+choice
+	prompt "LED breathe implementation"
+	default LEDS_TRIGGER_BREATHE
+            
+	config LEDS_TRIGGER_BREATHE_BCM
+		tristate "BCM LED Breathe Trigger"
+		depends on LEDS_TRIGGERS
+		help
+	  	This allows LEDs to use the pulsating feature of BCM LED controller
+
+	config LEDS_TRIGGER_BREATHE
+		tristate "LED Breathe Trigger"
+		depends on LEDS_TRIGGERS
+		help
+	  	This allows LEDs to blinking like breathe
+	  	If unsure, say Y.
+endchoice
+
+config LEDS_TRIGGER_PATTERN
+	tristate "LED Pattern Trigger"
+	depends on LEDS_TRIGGERS
+	help
+	  This allows LEDs to blink based on configured patttern
+	  If unsure, say Y.
+
+config LEDS_TRIGGER_MORSE
+	tristate "LED Morse Trigger"
+	depends on LEDS_TRIGGERS
+
 config LEDS_TRIGGER_CPU
 	bool "LED CPU Trigger"
 	depends on LEDS_TRIGGERS
--- a/kernel/linux-4.1/drivers/leds/trigger/Makefile
+++ b/kernel/linux-4.1/drivers/leds/trigger/Makefile
@@ -8,3 +8,7 @@ obj-$(CONFIG_LEDS_TRIGGER_CPU)		+= ledtr
 obj-$(CONFIG_LEDS_TRIGGER_DEFAULT_ON)	+= ledtrig-default-on.o
 obj-$(CONFIG_LEDS_TRIGGER_TRANSIENT)	+= ledtrig-transient.o
 obj-$(CONFIG_LEDS_TRIGGER_CAMERA)	+= ledtrig-camera.o
+obj-$(CONFIG_LEDS_TRIGGER_BREATHE_BCM)	+= ledtrig-breathe-bcm.o
+obj-$(CONFIG_LEDS_TRIGGER_BREATHE)	+= ledtrig-breathe.o
+obj-$(CONFIG_LEDS_TRIGGER_PATTERN)	+= ledtrig-pattern.o
+obj-$(CONFIG_LEDS_TRIGGER_MORSE)	+= ledtrig-morse.o
--- /dev/null
+++ b/kernel/linux-4.1/drivers/leds/trigger/ledtrig-breathe-bcm.c
@@ -0,0 +1,96 @@
+/*
+ * LED Kernel Breathe Trigger
+ *
+ * Copyright 20016 Plume Design Inc.
+ *
+ * Author: Hong Fan <hong@wildfire.exchange>
+ * Author: Mitja Horvat <mitja@plumewifi.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/leds.h>
+#include "../leds.h"
+
+
+#define BRCM_LED_PWM_GPIO_OFFSET			22	/*should be the same as the pwm-offset definition for LED in 47622.dts*/
+#define BRCM_LED_CONFIG0_PULSATING 			2
+#define BRCM_LED_CONFIG0_REPEAT             		(1 << 14)
+#define BRCM_LED_CONFIG0_DIRECT             		(1 << 15)
+#define BRCM_LED_CONFIG0_INIT_DELAY_SHIFT		21
+#define BRCM_LED_CONFIG0_INIT_DELAY			(3 << BRCM_LED_CONFIG0_INIT_DELAY_SHIFT)	/*3bits*/
+#define BRCM_LED_CONFIG0_FINAL_DELAY_SHIFT		24
+#define BRCM_LED_CONFIG0_FINAL_DELAY			(6 << BRCM_LED_CONFIG0_FINAL_DELAY_SHIFT)	/*4bits*/
+#define BRCM_LED_CONFIG1_LVL1_BSTEP			3
+#define BRCM_LED_CONFIG1_LVL1_TSTEP_SHIFT		4
+#define BRCM_LED_CONFIG1_LVL1_TSTEP			(3 << BRCM_LED_CONFIG1_LVL1_TSTEP_SHIFT)	/*4bits for all step settings*/
+#define BRCM_LED_CONFIG1_LVL1_NSTEP_SHIFT		8
+#define BRCM_LED_CONFIG1_LVL1_NSTEP			(10 << BRCM_LED_CONFIG1_LVL1_NSTEP_SHIFT)
+#define BRCM_LED_CONFIG1_LVL2_BSTEP_SHIFT		12
+#define BRCM_LED_CONFIG1_LVL2_BSTEP			(6 << BRCM_LED_CONFIG1_LVL2_BSTEP_SHIFT)
+#define BRCM_LED_CONFIG1_LVL2_TSTEP_SHIFT		16
+#define BRCM_LED_CONFIG1_LVL2_TSTEP			(3 << BRCM_LED_CONFIG1_LVL2_TSTEP_SHIFT)
+#define BRCM_LED_CONFIG1_LVL2_NSTEP_SHIFT		20
+#define BRCM_LED_CONFIG1_LVL2_NSTEP			(11 << BRCM_LED_CONFIG1_LVL2_NSTEP_SHIFT)
+#define BRCM_LED_CONFIG2_LVL3_BSTEP			3
+#define BRCM_LED_CONFIG2_LVL3_TSTEP_SHIFT		4
+#define BRCM_LED_CONFIG2_LVL3_TSTEP			(3 << BRCM_LED_CONFIG2_LVL3_TSTEP_SHIFT)
+#define BRCM_LED_CONFIG2_LVL3_NSTEP_SHIFT		8
+#define BRCM_LED_CONFIG2_LVL3_NSTEP			(10 << BRCM_LED_CONFIG2_LVL3_NSTEP_SHIFT)
+
+
+/*
+ * The *set_brightness_work* & *blink_timer* of *led_classdev* structure are cleaned up by led_trigger.c whenever trigger is removed.
+ * We don't need to clean up the workqueue of *led_pwm_data* structure due to *can_sleep* is not set in pwm_bcm6755.c.
+ */
+static void breathe_trig_activate(struct led_classdev *led_cdev)
+{
+	extern void led_set_breathecfg(unsigned int gpio_num, unsigned int config[]);
+	extern void led_set_active(unsigned int gpio_num, unsigned int enable);
+	unsigned int config[3];
+
+	config[0] = BRCM_LED_CONFIG0_PULSATING | BRCM_LED_CONFIG0_REPEAT | BRCM_LED_CONFIG0_DIRECT | BRCM_LED_CONFIG0_INIT_DELAY | BRCM_LED_CONFIG0_FINAL_DELAY;
+	config[1] = BRCM_LED_CONFIG1_LVL1_BSTEP | BRCM_LED_CONFIG1_LVL1_TSTEP | BRCM_LED_CONFIG1_LVL1_NSTEP | BRCM_LED_CONFIG1_LVL2_BSTEP | BRCM_LED_CONFIG1_LVL2_TSTEP | BRCM_LED_CONFIG1_LVL2_NSTEP;
+	config[2] = BRCM_LED_CONFIG2_LVL3_BSTEP | BRCM_LED_CONFIG2_LVL3_TSTEP | BRCM_LED_CONFIG2_LVL3_NSTEP;
+
+	led_set_breathecfg(BRCM_LED_PWM_GPIO_OFFSET, config);
+	led_set_active(BRCM_LED_PWM_GPIO_OFFSET, 1);
+}
+
+static void breathe_trig_deactivate(struct led_classdev *led_cdev)
+{
+	extern void led_set_breathecfg(unsigned int gpio_num, unsigned int config[]);
+	extern void led_set_active(unsigned int gpio_num, unsigned int enable);
+	unsigned int config[3] = {0, 0, 0};
+
+	led_set_breathecfg(BRCM_LED_PWM_GPIO_OFFSET, config);
+	led_set_active(BRCM_LED_PWM_GPIO_OFFSET, 1);
+}
+
+static struct led_trigger breathe_led_trigger = {
+	.name     = "breathe",
+	.activate = breathe_trig_activate,
+	.deactivate = breathe_trig_deactivate,
+};
+
+static int __init breathe_trig_init(void)
+{
+	return led_trigger_register(&breathe_led_trigger);
+}
+
+static void __exit breathe_trig_exit(void)
+{
+	led_trigger_unregister(&breathe_led_trigger);
+}
+
+module_init(breathe_trig_init);
+module_exit(breathe_trig_exit);
+
+MODULE_DESCRIPTION("Breathe LED trigger");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/kernel/linux-4.1/drivers/leds/trigger/ledtrig-breathe.c
@@ -0,0 +1,198 @@
+/*
+ * LED Kernel Breathe Trigger
+ *
+ * Copyright 20016 Plume Design Inc.
+ *
+ * Author: Hong Fan <hong@wildfire.exchange>
+ * Author: Mitja Horvat <mitja@plumewifi.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/hrtimer.h>
+#include <linux/sched.h>
+#include <linux/leds.h>
+#include "../leds.h"
+
+struct breathe_trig_data
+{
+	struct led_classdev *led_cdev;
+	unsigned long phase;
+	unsigned long on_delay_us;
+	unsigned long blinks;
+
+	struct hrtimer phase_timer;
+	struct hrtimer blink_timer;
+};
+
+/* Number of steps in the breathe phase */
+#define BREATHE_PHASE_MAX 	50
+/*
+ * in msecs; interval at which the phase will increment
+ * Multiplying this by BREATHE_PHASE_MAX will give you the total phase duration
+ */
+#define BREATHE_PHASE_INVL	50
+
+/* in msecs; Total blink phase duration (on + off time) */
+#define BLINK_PHASE_INVL	10
+
+static enum hrtimer_restart blink_timer(struct hrtimer *timer)
+{
+	unsigned long brightness;
+	unsigned long delay_us;
+
+	struct breathe_trig_data *breathe_data = container_of(
+			timer,
+			struct breathe_trig_data,
+			blink_timer);
+
+	do
+	{
+		delay_us = breathe_data->on_delay_us;
+
+		if ((breathe_data->blinks++ & 1) == 0)
+		{
+			brightness = LED_FULL;
+		}
+		else
+		{
+			brightness = LED_OFF;
+			delay_us = BLINK_PHASE_INVL * USEC_PER_MSEC - delay_us;
+		}
+	}
+	while (delay_us == 0);
+
+	/* Turn on/off the LED */
+	led_set_brightness(breathe_data->led_cdev, brightness);
+
+	/* Re-arm the timer */
+	hrtimer_forward_now(timer, ns_to_ktime(delay_us * NSEC_PER_USEC));
+
+	return HRTIMER_RESTART;
+}
+
+static enum hrtimer_restart phase_timer(struct hrtimer *timer)
+{
+	unsigned long delay_us;
+
+	struct breathe_trig_data *breathe_data = container_of(
+			timer,
+			struct breathe_trig_data,
+			phase_timer);
+
+	breathe_data->phase++;
+	breathe_data->phase %= BREATHE_PHASE_MAX;
+
+	/*
+	 * The phase is cropped using %, so it basically generates a /|/|/| pattern. Convert
+	 * it to a /\/\/\/\ pattern.
+	 */
+	if (breathe_data->phase >= (BREATHE_PHASE_MAX / 2))
+	{
+		delay_us = BREATHE_PHASE_MAX - breathe_data->phase;
+	}
+	else
+	{
+		delay_us = breathe_data->phase;
+	}
+
+	delay_us <<= 1;
+
+	/*
+	 *
+	 * The duration of the LED on + off period is always BLINK_PHASE_INVL; The on/off time is scaled
+	 * according to the brightness we want to achieve.
+	 *
+	 * The greater the on timer compared to the off time the brighter the LED
+	 *
+	 * Convert the delay from the phase number to microseconds
+	 */
+	delay_us = (BLINK_PHASE_INVL * USEC_PER_MSEC * delay_us + (BREATHE_PHASE_MAX >> 1)) / BREATHE_PHASE_MAX;
+
+	breathe_data->on_delay_us = delay_us;
+
+	/* Re-arm the timer */
+	hrtimer_forward_now(timer, ms_to_ktime(BREATHE_PHASE_INVL));
+
+	return HRTIMER_RESTART;
+}
+
+static void
+breathe_trig_activate(struct led_classdev *led_cdev)
+{
+	struct breathe_trig_data *breathe_data;
+
+	breathe_data = kzalloc(sizeof(*breathe_data), GFP_KERNEL);
+	if (!breathe_data) return;
+
+	breathe_data->led_cdev = led_cdev;
+	breathe_data->phase = 0;
+	breathe_data->on_delay_us =  0;
+	breathe_data->blinks = 0;
+
+	led_cdev->trigger_data = breathe_data;
+
+	/* Initialize the blink timer */
+	hrtimer_init(&breathe_data->blink_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	breathe_data->blink_timer.function = blink_timer;
+	hrtimer_start(
+			&breathe_data->blink_timer,
+			ms_to_ktime(0),
+			HRTIMER_MODE_REL);
+
+	/* Initialize the phase timer */
+	hrtimer_init(&breathe_data->phase_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	breathe_data->phase_timer.function = phase_timer;
+	hrtimer_start(
+			&breathe_data->phase_timer,
+			ms_to_ktime(BREATHE_PHASE_INVL),
+			HRTIMER_MODE_REL);
+}
+
+static void
+breathe_trig_deactivate(struct led_classdev *led_cdev)
+{
+	struct breathe_trig_data *breathe_data = led_cdev->trigger_data;
+
+	/* Stop blinking */
+	led_set_brightness(led_cdev, LED_OFF);
+
+	if (breathe_data == NULL) return;
+
+	hrtimer_cancel(&breathe_data->blink_timer);
+	hrtimer_cancel(&breathe_data->phase_timer);
+
+	kfree(breathe_data);
+
+	led_cdev->trigger_data = NULL;
+}
+
+static struct led_trigger breathe_led_trigger = {
+	.name     = "breathe",
+	.activate = breathe_trig_activate,
+	.deactivate = breathe_trig_deactivate,
+};
+
+static int __init breathe_trig_init(void)
+{
+	return led_trigger_register(&breathe_led_trigger);
+}
+
+static void __exit breathe_trig_exit(void)
+{
+	led_trigger_unregister(&breathe_led_trigger);
+}
+
+module_init(breathe_trig_init);
+module_exit(breathe_trig_exit);
+
+MODULE_AUTHOR("Hong Fan <hongfan@wildfire.exchange>, Mitja Horvat <mitja@plumewifi.com>");
+MODULE_DESCRIPTION("Breathe LED trigger");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/kernel/linux-4.1/drivers/leds/trigger/ledtrig-morse.c
@@ -0,0 +1,363 @@
+/*
+ *  LED Morse Trigger
+ *
+ *  Copyright (C) 2007 Gabor Juhos <juhosg at openwrt.org>
+ *
+ *  This file was based on: drivers/led/ledtrig-timer.c
+ *	Copyright 2005-2006 Openedhand Ltd.
+ *	Author: Richard Purdie <rpurdie@openedhand.com>
+ *
+ *  also based on the patch '[PATCH] 2.5.59 morse code panics' posted
+ *  in the LKML by Tomas Szepe at Thu, 30 Jan 2003
+ *	Copyright (C) 2002 Andrew Rodland <arodland@noln.com>
+ *	Copyright (C) 2003 Tomas Szepe <szepe@pinerecords.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/timer.h>
+#include <linux/ctype.h>
+#include <linux/leds.h>
+#include <linux/slab.h>
+
+#define MORSE_DELAY_BASE	(HZ/2)
+
+#define MORSE_STATE_BLINK_START	0
+#define MORSE_STATE_BLINK_STOP	1
+
+#define MORSE_DIT_LEN	1
+#define MORSE_DAH_LEN	3
+#define MORSE_SPACE_LEN	7
+
+struct morse_trig_data {
+	unsigned long delay;
+	char *msg;
+
+	unsigned char morse;
+	unsigned char state;
+	char *msgpos;
+	struct timer_list timer;
+};
+
+const unsigned char morsetable[] = {
+	0122, 0, 0310, 0, 0, 0163,				/* "#$%&' */
+	055, 0155, 0, 0, 0163, 0141, 0152, 0051, 		/* ()*+,-./ */
+	077, 076, 074, 070, 060, 040, 041, 043, 047, 057,	/* 0-9 */
+	0107, 0125, 0, 0061, 0, 0114, 0, 			/* :;<=>?@ */
+	006, 021, 025, 011, 002, 024, 013, 020, 004,		/* A-I */
+	036, 015, 022, 007, 005, 017, 026, 033, 012,		/* J-R */
+	010, 003, 014, 030, 016, 031, 035, 023,			/* S-Z */
+	0, 0, 0, 0, 0154					/* [\]^_ */
+};
+
+static inline unsigned char tomorse(char c) {
+	if (c >= 'a' && c <= 'z')
+		c = c - 'a' + 'A';
+	if (c >= '"' && c <= '_') {
+		return morsetable[c - '"'];
+	} else
+		return 0;
+}
+
+static inline unsigned long dit_len(struct morse_trig_data *morse_data)
+{
+	return MORSE_DIT_LEN*morse_data->delay;
+}
+
+static inline unsigned long dah_len(struct morse_trig_data *morse_data)
+{
+	return MORSE_DAH_LEN*morse_data->delay;
+}
+
+static inline unsigned long space_len(struct morse_trig_data *morse_data)
+{
+	return MORSE_SPACE_LEN*morse_data->delay;
+}
+
+static void morse_timer_function(unsigned long data)
+{
+	struct led_classdev *led_cdev = (struct led_classdev *)data;
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+	unsigned long brightness = LED_OFF;
+	unsigned long delay = 0;
+
+	if (!morse_data->msg)
+		goto set_led;
+
+	switch (morse_data->state) {
+	case MORSE_STATE_BLINK_START:
+		/* Starting a new blink.  We have a valid code in morse. */
+		delay = (morse_data->morse & 001) ? dah_len(morse_data):
+			dit_len(morse_data);
+		brightness = LED_FULL;
+		morse_data->state = MORSE_STATE_BLINK_STOP;
+		morse_data->morse >>= 1;
+		break;
+	case MORSE_STATE_BLINK_STOP:
+		/* Coming off of a blink. */
+		morse_data->state = MORSE_STATE_BLINK_START;
+
+		if (morse_data->morse > 1) {
+			/* Not done yet, just a one-dit pause. */
+			delay = dit_len(morse_data);
+			break;
+		}
+
+		/* Get a new char, figure out how much space. */
+		/* First time through */
+		if (!morse_data->msgpos)
+			morse_data->msgpos = (char *)morse_data->msg;
+
+		if (!*morse_data->msgpos) {
+			/* Repeating */
+			morse_data->msgpos = (char *)morse_data->msg;
+			delay = space_len(morse_data);
+		} else {
+			/* Inter-letter space */
+			delay = dah_len(morse_data);
+		}
+
+		if (!(morse_data->morse = tomorse(*morse_data->msgpos))) {
+			delay = space_len(morse_data);
+			/* And get us back here */
+			morse_data->state = MORSE_STATE_BLINK_STOP;
+		}
+		morse_data->msgpos++;
+		break;
+	}
+
+	mod_timer(&morse_data->timer, jiffies + msecs_to_jiffies(delay));
+
+set_led:
+	led_set_brightness(led_cdev, brightness);
+}
+
+static ssize_t _morse_delay_show(struct led_classdev *led_cdev, char *buf)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+
+	sprintf(buf, "%lu\n", morse_data->delay);
+
+	return strlen(buf) + 1;
+}
+
+static ssize_t _morse_delay_store(struct led_classdev *led_cdev,
+		const char *buf, size_t size)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+	char *after;
+	unsigned long state = simple_strtoul(buf, &after, 10);
+	size_t count = after - buf;
+	int ret = -EINVAL;
+
+	if (*after && isspace(*after))
+		count++;
+
+	if (count == size) {
+		morse_data->delay = state;
+		mod_timer(&morse_data->timer, jiffies + 1);
+		ret = count;
+	}
+
+	return ret;
+}
+
+static ssize_t _morse_msg_show(struct led_classdev *led_cdev, char *buf)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+
+	if (!morse_data->msg)
+		sprintf(buf, "<none>\n");
+	else
+		sprintf(buf, "%s\n", morse_data->msg);
+
+	return strlen(buf) + 1;
+}
+
+static ssize_t _morse_msg_store(struct led_classdev *led_cdev,
+		const char *buf, size_t size)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+	char *m;
+
+	m = kmalloc(size, GFP_KERNEL);
+	if (!m)
+		return -ENOMEM;
+
+	memcpy(m,buf,size);
+	m[size]='\0';
+
+	if (morse_data->msg)
+		kfree(morse_data->msg);
+
+	morse_data->msg = m;
+	morse_data->msgpos = NULL;
+	morse_data->state = MORSE_STATE_BLINK_STOP;
+
+	mod_timer(&morse_data->timer, jiffies + 1);
+
+	return size;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+static ssize_t morse_delay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+
+	return _morse_delay_show(led_cdev, buf);
+}
+
+static ssize_t morse_delay_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+
+	return _morse_delay_store(led_cdev, buf, size);
+}
+
+static ssize_t morse_msg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+
+	return _morse_msg_show(led_cdev, buf);
+}
+
+static ssize_t morse_msg_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+
+	return _morse_msg_store(led_cdev, buf, size);
+}
+
+static DEVICE_ATTR(delay, 0644, morse_delay_show, morse_delay_store);
+static DEVICE_ATTR(message, 0644, morse_msg_show, morse_msg_store);
+
+#define led_device_create_file(leddev, attr) \
+	device_create_file(leddev->dev, &dev_attr_ ## attr)
+#define led_device_remove_file(leddev, attr) \
+	device_remove_file(leddev->dev, &dev_attr_ ## attr)
+
+#else
+static ssize_t morse_delay_show(struct class_device *dev, char *buf)
+{
+	struct led_classdev *led_cdev = class_get_devdata(dev);
+
+	return _morse_delay_show(led_cdev, buf);
+}
+
+static ssize_t morse_delay_store(struct class_device *dev, const char *buf,
+		size_t size)
+{
+	struct led_classdev *led_cdev = class_get_devdata(dev);
+
+	return _morse_delay_store(led_cdev, buf, size);
+}
+
+static ssize_t morse_msg_show(struct class_device *dev, char *buf)
+{
+	struct led_classdev *led_cdev = class_get_devdata(dev);
+
+	return _morse_msg_show(led_cdev, buf);
+}
+
+static ssize_t morse_msg_store(struct class_device *dev, const char *buf,
+				size_t size)
+{
+	struct led_classdev *led_cdev = class_get_devdata(dev);
+
+	return _morse_msg_store(led_cdev, buf, size);
+}
+
+static CLASS_DEVICE_ATTR(delay, 0644, morse_delay_show, morse_delay_store);
+static CLASS_DEVICE_ATTR(message, 0644, morse_msg_show, morse_msg_store);
+
+#define led_device_create_file(leddev, attr) \
+	class_device_create_file(leddev->class_dev, &class_device_attr_ ## attr)
+#define led_device_remove_file(leddev, attr) \
+	class_device_remove_file(leddev->class_dev, &class_device_attr_ ## attr)
+
+#endif
+
+static void morse_trig_activate(struct led_classdev *led_cdev)
+{
+	struct morse_trig_data *morse_data;
+	int rc;
+
+	morse_data = kzalloc(sizeof(*morse_data), GFP_KERNEL);
+	if (!morse_data)
+		return;
+
+	morse_data->delay = MORSE_DELAY_BASE;
+	init_timer(&morse_data->timer);
+	morse_data->timer.function = morse_timer_function;
+	morse_data->timer.data = (unsigned long)led_cdev;
+
+	rc = led_device_create_file(led_cdev, delay);
+	if (rc) goto err;
+
+	rc = led_device_create_file(led_cdev, message);
+	if (rc) goto err_delay;
+
+	led_cdev->trigger_data = morse_data;
+
+	return;
+
+err_delay:
+	led_device_remove_file(led_cdev, delay);
+err:
+	kfree(morse_data);
+}
+
+static void morse_trig_deactivate(struct led_classdev *led_cdev)
+{
+	struct morse_trig_data *morse_data = led_cdev->trigger_data;
+
+	if (!morse_data)
+		return;
+
+	led_device_remove_file(led_cdev, message);
+	led_device_remove_file(led_cdev, delay);
+
+	del_timer_sync(&morse_data->timer);
+	if (morse_data->msg)
+		kfree(morse_data->msg);
+
+	kfree(morse_data);
+}
+
+static struct led_trigger morse_led_trigger = {
+	.name		= "morse",
+	.activate	= morse_trig_activate,
+	.deactivate	= morse_trig_deactivate,
+};
+
+static int __init morse_trig_init(void)
+{
+	return led_trigger_register(&morse_led_trigger);
+}
+
+static void __exit morse_trig_exit(void)
+{
+	led_trigger_unregister(&morse_led_trigger);
+}
+
+module_init(morse_trig_init);
+module_exit(morse_trig_exit);
+
+MODULE_AUTHOR("Gabor Juhos <juhosg at openwrt.org>");
+MODULE_DESCRIPTION("Morse LED trigger");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/kernel/linux-4.1/drivers/leds/trigger/ledtrig-pattern.c
@@ -0,0 +1,204 @@
+/*
+ * LED Kernel Blink Pattern Trigger
+ *
+ * Copyright 2016 Plume Design Inc.
+ *
+ * Author: Yongseok Joo (yongseok@plumewifi.com)
+ * This module allows a user to configure blinking pattern on leds
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <linux/leds.h>
+#include "../leds.h"
+
+#define MAX_PATTERN_NUM     8
+#define MAX_PATTERN_STR_LEN 128
+
+/* pattern_trig_data : pattern, # of pattern, total time(peirod), and timer */
+struct pattern_trig_data {
+	unsigned int curr_idx;
+	unsigned int pattern[MAX_PATTERN_NUM];
+	struct timer_list timer;
+};
+
+/* default pattern */
+static int default_pattern[] = { 400000, 250000, 500000, 1000000, 400000, 250000, 500000, 1000000 };
+
+static int validate_pattern(char *str) {
+	int ret = 0, len = 0;
+
+	len = strlen(str);
+
+	if(len == 0) {
+		printk(KERN_ERR "%s: zero length pattern.\n", __func__);
+		goto error;
+	}
+
+	if(len > MAX_PATTERN_STR_LEN) {
+		printk(KERN_ERR "%s: too long pattern(%d).\n", __func__, len);
+		goto error;
+	}
+
+	while(*(++str)) {
+		if(*str == ' ' || *str == '\n')
+			continue;
+
+		if((*str > '9') || (*str < '0')) {
+			printk(KERN_ERR "%s: invalid character(\'%c\') in pattern\n", __func__, *str);
+			goto error;
+		}
+	}
+
+	ret = 1;
+
+error:
+	return ret;
+}
+
+/* creating pattern and schedule timer */
+static void led_blink_pattern(unsigned long data)
+{
+
+	struct led_classdev *led_cdev = (struct led_classdev *) data;
+	struct pattern_trig_data *t_data = led_cdev->trigger_data;
+
+	/* avoiding overflow of array index */
+	if(t_data->curr_idx >= MAX_PATTERN_NUM)
+		t_data->curr_idx = 0;
+
+	/* if curr_idx is even, then on / if it is odd, then off */
+	if(t_data->curr_idx % 2) {
+		led_set_brightness(led_cdev, LED_FULL);
+	} else {
+		led_set_brightness(led_cdev, LED_OFF);
+	}
+
+	mod_timer(&t_data->timer, jiffies + usecs_to_jiffies(t_data->pattern[t_data->curr_idx]));
+	t_data->curr_idx++;
+}
+
+static ssize_t led_blink_pattern_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	int *p_data = ((struct pattern_trig_data *)led_cdev->trigger_data)->pattern;
+
+	return sprintf(buf, "%u %u %u %u %u %u %u %u\n",
+			p_data[0], p_data[1], p_data[2], p_data[3], p_data[4], p_data[5], p_data[6], p_data[7]);
+}
+
+static ssize_t led_blink_pattern_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t size)
+{
+	int ret = 0;
+	char pattern_str[MAX_PATTERN_STR_LEN + 1];
+
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct pattern_trig_data *t_data = led_cdev->trigger_data;
+	int *p_data = ((struct pattern_trig_data *)led_cdev->trigger_data)->pattern;;
+
+	memset(pattern_str, 0, sizeof(pattern_str));
+	strncpy(pattern_str, buf, MAX_PATTERN_STR_LEN);
+
+	if(!validate_pattern(pattern_str))
+		return -EINVAL;
+
+	/* Remove previous value in the structure */
+	t_data->curr_idx = 0;
+	memset(p_data, 0, (sizeof(int) * MAX_PATTERN_NUM));
+	ret = sscanf(pattern_str, "%u %u %u %u %u %u %u %u",
+			&p_data[0], &p_data[1], &p_data[2], &p_data[3], &p_data[4], &p_data[5], &p_data[6], &p_data[7]);
+
+	if(!ret) {
+		printk(KERN_ERR "%s: invalid pattern(\"%s\")\n", __func__, pattern_str);
+		return -EINVAL;
+	}
+
+	printk(KERN_INFO "%s: %u %u %u %u %u %u %u %u\n", __func__,
+			p_data[0], p_data[1], p_data[2], p_data[3], p_data[4], p_data[5], p_data[6], p_data[7]);
+
+	/* reset the LEDs */
+	led_blink_pattern((unsigned long)led_cdev);
+
+	return size;
+}
+
+/* pattern configuration file */
+static DEVICE_ATTR(pattern, 0644, led_blink_pattern_show, led_blink_pattern_store);
+
+static void
+pattern_trig_activate(struct led_classdev *led_cdev)
+{
+	int rc;
+	struct pattern_trig_data *t_data;
+	int *p_data;
+
+	/* creating pattern file for user input and review */
+	rc = device_create_file(led_cdev->dev, &dev_attr_pattern);
+	if(rc)
+		return;
+
+	t_data = kzalloc(sizeof(struct pattern_trig_data), GFP_KERNEL);
+	if (!t_data) {
+		/* fail-exit case. need to destroy device file */
+		device_remove_file(led_cdev->dev, &dev_attr_pattern);
+		return;
+	}
+
+	/* initialize the pattern data */
+	t_data->curr_idx = 0;
+	memcpy(t_data->pattern, default_pattern, sizeof(t_data->pattern));
+	p_data = t_data->pattern;
+
+	printk(KERN_INFO "%s: initializing....\n", __func__);
+	printk(KERN_INFO "%s: %u %u %u %u %u %u %u %u\n", __func__,
+			p_data[0], p_data[1], p_data[2], p_data[3], p_data[4], p_data[5], p_data[6], p_data[7]);
+
+	led_cdev->trigger_data = t_data;
+
+	setup_timer(&t_data->timer,
+			led_blink_pattern, (unsigned long)led_cdev);
+
+	led_blink_pattern(t_data->timer.data);
+}
+
+static void
+pattern_trig_deactivate(struct led_classdev *led_cdev)
+{
+	struct pattern_trig_data *t_data= led_cdev->trigger_data;
+
+	if (t_data) {
+		del_timer_sync(&t_data->timer);
+		device_remove_file(led_cdev->dev, &dev_attr_pattern);
+		kfree(t_data);
+	}
+}
+
+static struct led_trigger pattern_led_trigger = {
+	.name     = "pattern",
+	.activate = pattern_trig_activate,
+	.deactivate = pattern_trig_deactivate,
+};
+
+static int __init pattern_trig_init(void)
+{
+	return led_trigger_register(&pattern_led_trigger);
+}
+
+static void __exit pattern_trig_exit(void)
+{
+	led_trigger_unregister(&pattern_led_trigger);
+}
+
+module_init(pattern_trig_init);
+module_exit(pattern_trig_exit);
+
+MODULE_AUTHOR("Yongseok Joo <yongseok@plumewifi.com>");
+MODULE_DESCRIPTION("Pattern LED Trigger");
+MODULE_LICENSE("GPLv2");
