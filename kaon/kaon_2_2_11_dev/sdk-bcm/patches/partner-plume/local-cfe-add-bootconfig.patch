--- a/cfe/build/broadcom/bcm63xx_ram/Makefile
+++ b/cfe/build/broadcom/bcm63xx_ram/Makefile
@@ -337,6 +337,11 @@ export CONFIG_GPL_RDP
 export CONFIG_GPL_RDP_GEN
 endif
 
+ifeq ("$(BUILD_BOOTCONFIG)", "y")
+CFLAGS += -DBUILD_BOOTCONFIG
+CFLAGS += -DBUILD_BOOTCONFIG_RECOVERY_FILENAME="\"$(BUILD_BOOTCONFIG_RECOVERY_FILENAME)\""
+endif
+
 rdp:
 ifeq ("$(CONFIG_GPL_RDP)", "1")
 	mkdir -p $(XRDP_DIR)
--- a/cfe/cfe/board/bcm63xx_ram/src/Makefile
+++ b/cfe/cfe/board/bcm63xx_ram/src/Makefile
@@ -428,3 +428,7 @@ ifeq ($(strip ${CFG_DT}),1)
 BSPOBJS +=                  \
 	bcm63xx_dtb.o
 endif
+
+ifeq ("$(BUILD_BOOTCONFIG)", "y")
+BSPOBJS += cfe_bc.o
+endif
--- a/cfe/cfe/board/bcm63xx_ram/src/bcm63xx_cmd.c
+++ b/cfe/cfe/board/bcm63xx_ram/src/bcm63xx_cmd.c
@@ -109,6 +109,10 @@ static struct optee_boot_param_t params;
 static char derived_device_key[] = "key derrived from otped device key";
 #endif /* BCM_OPTEE */
 
+#if defined(BUILD_BOOTCONFIG)
+#include "cfe_bc.h"
+#endif
+
 #define je16_to_cpu(x) ((x).v16)
 #define je32_to_cpu(x) ((x).v32)
 
@@ -1613,6 +1617,51 @@ static int bootNandImageFromRootfs(int s
     return( ret );
 }
 
+#if defined(BUILD_BOOTCONFIG)
+static int flash_recovery(void)
+{
+    char hostImageName[BOOT_FILENAME_LEN + BOOT_IP_LEN];
+    char imageName[] = BUILD_BOOTCONFIG_RECOVERY_FILENAME;
+    uint8_t *ptr = (uint8_t *) cfe_get_mempool_ptr();
+    int res;
+
+#if (NONETWORK==0)
+    if (g_in_cfe == 0) {
+        int i;
+        board_netdevice_init();
+        enet_init();
+        /* trying to POLL devices */
+        for (i = 0; i < 20; i++) {
+            POLL();
+            cfe_sleep(CFE_HZ/4);
+        }
+        g_in_cfe = 1;
+    }
+#endif
+
+    strcpy(hostImageName, bootInfo.hostIp);
+    strcat(hostImageName, ":");
+    strcat(hostImageName, imageName);
+
+    do {
+        res = loadRaw(hostImageName, ptr);
+    }
+    while (res < 0);
+
+    // Wait for eth to be ready
+    cfe_sleep(CFE_HZ);
+
+    res = writeWholeImage(ptr, res);
+    if (res != 0)
+    {
+        printf("Error flashing new image.\n");
+        return res;
+    }
+
+    return 0;
+}
+#endif /* defined(BUILD_BOOTCONFIG) */
+
 static int bootNandImage(void)
 {
     int ret = -1;
@@ -1628,6 +1677,40 @@ static int bootNandImage(void)
 
     validateNandPartTbl(0, 0);
 
+#if defined(BUILD_BOOTCONFIG)
+    int rv;
+    struct bootcfg_nand_log bc_log;
+    enum bootcfg_location bc_loc1;
+    enum bootcfg_location bc_loc2;
+
+    bootcfg_open();
+    rv = bootcfg_get_last_log(&bc_log);
+    if (rv == BOOTCFG_RC_ERR_LOG_EMPTY)
+    {
+        printf("Bootconfig log is empty\n");
+    }
+    else if (rv != BOOTCFG_RC_OK)
+    {
+        printf("ERROR: bootcfg_get_last_log(); %d\n", rv);
+    }
+    else
+    {
+        bootcfg_dump_log(&bc_log);
+
+        if ((bc_log.img[0].skip != 0xFFFFFFFFUL) && (bc_log.img[0].ignore_skip == 0xFFFFFFFFUL))
+        {
+            pTag1 = NULL;
+            seq1 = -1;
+        }
+
+        if ((bc_log.img[1].skip != 0xFFFFFFFFUL) && (bc_log.img[1].ignore_skip == 0xFFFFFFFFUL))
+        {
+            pTag2 = NULL;
+            seq2 = -1;
+        }
+    }
+#endif /* defined(BUILD_BOOTCONFIG) */
+
     if( pTag1 && pTag2 ) {
         /* Deal with wrap around case */
         if (seq1 == 0 && seq2 == 999)
@@ -1666,6 +1749,9 @@ static int bootNandImage(void)
             msgA = "Booting from latest image (address 0x%8.8lx, flash offset 0x%8.8lx) ...\n";
             msgB = "Booting from previous image (address 0x%8.8lx, flash offset 0x%8.8lx) ...\n";
             rootfsA = (seq2 > seq1) ? NP_ROOTFS_2 : NP_ROOTFS_1;
+#if defined(BUILD_BOOTCONFIG)
+            bc_loc1 = (seq2 > seq1) ? BOOTCFG_LOC_2 : BOOTCFG_LOC_1;
+#endif
         }
         else /* Boot from the previous image. */
         {
@@ -1674,13 +1760,23 @@ static int bootNandImage(void)
             msgA = "Booting from previous image (address 0x%8.8lx, flash offset 0x%8.8lx) ...\n";
             msgB = "Booting from latest image (address 0x%8.8lx, flash offset 0x%8.8lx) ...\n";
             rootfsA = (seq2 <= seq1) ? NP_ROOTFS_2 : NP_ROOTFS_1;
+#if defined(BUILD_BOOTCONFIG)
+            bc_loc1 = (seq2 <= seq1) ? BOOTCFG_LOC_2 : BOOTCFG_LOC_1;
+#endif
         }
 
         rootfsB = (rootfsA == NP_ROOTFS_2) ? NP_ROOTFS_1 : NP_ROOTFS_2;
+#if defined(BUILD_BOOTCONFIG)
+        bc_loc2 = (bc_loc1 == BOOTCFG_LOC_2) ? BOOTCFG_LOC_1 : BOOTCFG_LOC_2;
+#endif
         start_blk = NVRAM.ulNandPartOfsKb[rootfsA] / len;
         end_blk = start_blk +
             (NVRAM.ulNandPartSizeKb[rootfsA] / len);
         printf(msgA, FLASH_BASE + (NVRAM.ulNandPartOfsKb[rootfsA] * 1024), NVRAM.ulNandPartOfsKb[rootfsA] * 1024);
+
+#if defined(BUILD_BOOTCONFIG)
+        bootcfg_write_log_btldr(bc_loc1);
+#endif
         if((ret = bootNandImageFromRootfs(start_blk, end_blk, bootImgA, rootfsA)) != 0)
         {
             start_blk = NVRAM.ulNandPartOfsKb[rootfsB] / len;
@@ -1688,17 +1784,29 @@ static int bootNandImage(void)
                 (NVRAM.ulNandPartSizeKb[rootfsB] / len);
             printf(msgB, FLASH_BASE + (NVRAM.ulNandPartOfsKb[rootfsB]*1024), NVRAM.ulNandPartOfsKb[rootfsB]*1024);
             bootInfo.bootPartition = (bootImgB == BOOTED_OLD_IMAGE) ? BOOT_SET_OLD_IMAGE : BOOT_SET_NEW_IMAGE; // set booted image partition so correct dtb is loaded via cfe_fs_fetch_file
+#if defined(BUILD_BOOTCONFIG)
+            bootcfg_write_log_btldr(bc_loc2);
+#endif
             if((ret = bootNandImageFromRootfs(start_blk, end_blk,bootImgB, rootfsB))!= 0)
                 printf("Unable to boot image.\n");
         }
     }
     else
     {
-        if( pTag1 )
+        if( pTag1 ) {
             rootfsA = NP_ROOTFS_1;
-        else
-            if( pTag2 )
+#if defined(BUILD_BOOTCONFIG)
+            bc_loc1 = BOOTCFG_LOC_1;
+#endif
+        }
+        else {
+            if( pTag2 ) {
                 rootfsA = NP_ROOTFS_2;
+#if defined(BUILD_BOOTCONFIG)
+                bc_loc1 = BOOTCFG_LOC_2;
+#endif
+            }
+        }
 
         if( pTag1 || pTag2 )
         {
@@ -1707,15 +1815,33 @@ static int bootNandImage(void)
                 (NVRAM.ulNandPartSizeKb[rootfsA] / len);
             printf("Booting from only image (address 0x%8.8lx, flash offset 0x%8.8lx) ...\n",
                     FLASH_BASE + (NVRAM.ulNandPartOfsKb[rootfsA] * 1024), NVRAM.ulNandPartOfsKb[rootfsA] * 1024);
+#if defined(BUILD_BOOTCONFIG)
+            bootcfg_write_log_btldr(bc_loc1);
+#endif
             if( (ret = bootNandImageFromRootfs(start_blk, end_blk,
                 BOOTED_ONLY_IMAGE, rootfsA)) != 0 )
             {
                 printf("Unable to boot image.\n");
             }
         }
-        else
+        else {
             printf("No image found.\n");
+        }
+    }
+
+#if defined(BUILD_BOOTCONFIG)
+    /* if we got to here, it means there is no valid image on flash */
+    /* try TFTP recovery */
+    rv = flash_recovery();
+    if (rv == 0)
+    {
+        printf("Resetting bootconfig info ...\n");
+        cfe_bc_reset();
+        printf("Resetting CPU ...\n");
+        softReset(0);
     }
+#endif
+
     return( ret );
 }
 
@@ -4920,6 +5046,40 @@ static int ui_cmd_meminfo(ui_cmdline_t *
     return 0;
 }
 
+#if defined(BUILD_BOOTCONFIG)
+
+static int ui_cmd_bc_info(ui_cmdline_t *cmd, int argc, char *argv[])
+{
+    return cfe_bc_info();
+}
+
+static int ui_cmd_bc_reset(ui_cmdline_t *cmd, int argc, char *argv[])
+{
+    return cfe_bc_reset();
+}
+
+static int ui_cmd_bc_ignore_skip_img(ui_cmdline_t *cmd, int argc, char *argv[])
+{
+    enum bootcfg_location loc;
+    int rv;
+
+    rv = atoi(cmd_getarg(cmd, 0));
+    if (rv == 1)
+    {
+        loc = BOOTCFG_LOC_1;
+    }
+    else if (rv == 2)
+    {
+        loc = BOOTCFG_LOC_2;
+    }
+    else
+    {
+        return -1;
+    }
+
+    return cfe_bc_write_ignore_skip(loc);
+}
+#endif /* defined(BUILD_BOOTCONFIG) */
 
 static int ui_init_bcm63xx_cmds(void)
 {
@@ -5658,6 +5818,31 @@ static int ui_init_bcm63xx_cmds(void)
                "",
                BRCM_UI_CMD_TYPE_RESTRICTED);
 #endif
+
+#if defined(BUILD_BOOTCONFIG)
+  brcm_cmd_addcmd("bc_info",
+               ui_cmd_bc_info,
+               NULL,
+               "Show bootconfig info",
+               "bc_info",
+               "",
+               BRCM_UI_CMD_TYPE_RESTRICTED);
+  brcm_cmd_addcmd("bc_reset",
+               ui_cmd_bc_reset,
+               NULL,
+               "Reset bootconfig data",
+               "bc_reset",
+               "",
+               BRCM_UI_CMD_TYPE_RESTRICTED);
+  brcm_cmd_addcmd("bc_ignore_skip_img",
+               ui_cmd_bc_ignore_skip_img,
+               NULL,
+               "Write ignore skip image flag",
+               "bc_ignore_skip_img <1|2>",
+               "",
+               BRCM_UI_CMD_TYPE_RESTRICTED);
+#endif
+
         return 0;
 }
 
--- /dev/null
+++ b/cfe/cfe/include/cfe_bc.h
@@ -0,0 +1,130 @@
+/*  bootconfig - Boot configuration application for BCM platform with only
+ *  NAND flash
+ *
+ *  Copyright (C) 2018  Plume Design Inc.
+ */
+
+#ifndef __CFE_BC_H__
+#define __CFE_BC_H__
+
+
+/*
+#include <stdlib.h>
+#include <stdint.h>
+*/
+
+/**
+ * just because Broadcom use their own definitions of uint8_t/uint32_t/...
+ */
+#define __SLONGWORD_TYPE    long int
+# define __SWORD_TYPE                int
+
+#define __OFF_T_TYPE            __SLONGWORD_TYPE
+#define __SSIZE_T_TYPE          __SWORD_TYPE
+# define __STD_TYPE             __extension__ typedef
+
+__STD_TYPE __SSIZE_T_TYPE __ssize_t; /* Type of a byte count, or error.  */
+__STD_TYPE __OFF_T_TYPE __off_t;        /* Type of file sizes and offsets.  */
+
+
+#ifndef __off_t_defined
+# ifndef __USE_FILE_OFFSET64
+typedef __off_t off_t;
+# else
+typedef __off64_t off_t;
+# endif
+# define __off_t_defined
+#endif
+#if defined __USE_LARGEFILE64 && !defined __off64_t_defined
+typedef __off64_t off64_t;
+# define __off64_t_defined
+#endif
+
+
+#ifndef __ssize_t_defined
+typedef __ssize_t ssize_t;
+# define __ssize_t_defined
+#endif
+/**
+ * end
+ */
+
+
+
+#define BOOTCFG_BADCOUNT_THRESHOLD      (16)
+#define BOOTCFG_MAGIC                   (0xB001CF88UL)
+
+#define BOOTCFG_RC_OK                   (0)
+#define BOOTCFG_RC_ERR                  (-1)
+#define BOOTCFG_RC_ERR_SEEK             (-2)
+#define BOOTCFG_RC_ERR_READ             (-3)
+#define BOOTCFG_RC_ERR_WRITE            (-4)
+#define BOOTCFG_RC_ERR_ERASE            (-5)
+#define BOOTCFG_RC_ERR_VERIFY           (-6)
+#define BOOTCFG_RC_ERR_CHKSUM           (-7)
+#define BOOTCFG_RC_ERR_LOG_EMPTY        (-8)
+#define BOOTCFG_RC_ERR_MAGIC            (-9)
+#define BOOTCFG_RC_ERR_BADCOUNT_THRESHOLD_REACHED    (-100)
+
+
+struct bc_part_layout
+{
+    off_t offset;
+    ssize_t size;
+};
+
+struct bootcfg_nand_img
+{
+    uint32_t cnt_current;
+    uint32_t cnt_all_success;
+    uint32_t cnt_threshold;
+    uint32_t skip;
+    uint32_t ignore_skip;
+    uint8_t _res[12]; /* arbitrary alignment to 32 bytes */
+}  __attribute__ ((packed));
+
+struct bootcfg_nand_log
+{
+    uint32_t magic;
+    uint64_t uid;
+    uint32_t cnt_all_boots;
+    uint32_t cnt_all_success;
+    struct bootcfg_nand_img img[2];
+    uint8_t _res[40]; /* arbitrary alignment to 128 bytes */
+    uint32_t crc;
+}  __attribute__ ((packed));
+
+enum bootcfg_location
+{
+    BOOTCFG_LOC_UNKNOWN,
+    BOOTCFG_LOC_1,
+    BOOTCFG_LOC_2,
+};
+
+struct bootcfg_info
+{
+    off_t off_next_log;
+    struct bootcfg_nand_log *last_log;
+    uint8_t log_buf[2048]; /* TODO: should be NAND flash write pagesize */
+
+    ssize_t part_size;
+    ssize_t part_off;
+    ssize_t part_erasesize;
+    ssize_t part_writesize;
+};
+
+int cfe_bc_info(void);
+int cfe_bc_reset(void);
+int cfe_bc_write_ignore_skip(enum bootcfg_location loc);
+
+
+int bootcfg_open(void);
+int bootcfg_write_log_reset(void);
+int bootcfg_write_log_btldr(enum bootcfg_location location);
+int bootcfg_set_skip_img(enum bootcfg_location location);
+int bootcfg_set_ignore_skip_img(enum bootcfg_location location);
+int bootcfg_get_last_log(struct bootcfg_nand_log *log);
+void bootcfg_dump_log(struct bootcfg_nand_log *log);
+
+
+#endif
--- /dev/null
+++ b/cfe/cfe/main/cfe_bc.c
@@ -0,0 +1,771 @@
+/*  bootconfig - Boot configuration application for BCM platform with only
+ *  NAND flash
+ *
+ *  Copyright (C) 2018  Plume Design Inc.
+ */
+
+#include "bcm63xx_util.h"
+#include "bcm63xx_auth.h"
+#include "flash_api.h"
+#include "shared_utils.h"
+#include "jffs2.h"
+#include "lib_math.h"
+#if (INC_NAND_FLASH_DRIVER == 1) || (INC_SPI_PROG_NAND == 1) || (INC_SPI_NAND_DRIVER == 1)
+#include "bcm_ubi.h"
+#endif
+#if (INC_PMC_DRIVER==1)
+#include "pmc_drv.h"
+#include "BPCM.h"
+#include "clk_rst.h"
+#endif
+#if defined(_BCM94908_) || defined(_BCM963158_) || defined(_BCM963178_) || defined(_BCM947622_)
+#include "command.h"
+#endif
+#if defined (_BCM963268_) || defined (_BCM963381_)
+#include "mii_shared.h"
+#include "robosw_reg.h"
+#elif (defined (_BCM96838_) || defined (_BCM96848_)) && (NONETWORK==0)
+#include "phys_common_drv.h"
+#elif defined (_BCM960333_) || defined(_BCM947189_)
+#else
+#if (NONETWORK == 0)
+#include "bcm_ethsw.h"
+#endif
+#endif
+
+#include "bcm_otp.h"
+#if (INC_KERMIT==1) && (NONETWORK==1)
+#include "cfe_kermit.h"
+#endif
+#include "bcm63xx_blparms.h"
+#include "btrm_if.h"
+#if (defined (_BCM96838_) || defined (_BCM96848_) || defined (_BCM96858_) || defined (_BCM96846_) || defined (_BCM96856_) || defined (_BCM96878_) ) && (NONETWORK == 0)
+#include "rdp_cpu_ring.h"
+#endif
+#include "lib_byteorder.h"
+#include "lib_malloc.h"
+#include "lib_crc.h"
+#include "rom_parms.h"
+#include "bcm63xx_nvram.h"
+
+#if defined (_BCM96858_) && (NONETWORK == 0)
+#include "lport_drv.h"
+#include "lport_stats.h"
+#include "serdes_access.h"
+#include "bcm6858_lport_xlmac_ag.h"
+#define LPORT_MAX_PHY_ID (31)
+#endif
+
+#if (defined (_BCM96846_) || defined (_BCM96856_) || defined (_BCM96878_)) && (NONETWORK == 0)
+#include "mdio_drv_impl5.h"
+#include "mac_drv.h"
+#endif
+
+
+#include <stdbool.h>
+#include "cfe_bc.h"
+
+
+/**
+ * CFE Bootconfig UI
+ */
+
+
+int cfe_bc_info(void)
+{
+    int rv;
+    struct bootcfg_nand_log log;
+
+    bootcfg_open();
+
+    rv = bootcfg_get_last_log(&log);
+    if (rv == BOOTCFG_RC_ERR_LOG_EMPTY)
+    {
+        printf("Bootconfig log is empty\n");
+    }
+    else if (rv != BOOTCFG_RC_OK)
+    {
+        return rv;
+    }
+    bootcfg_dump_log(&log);
+
+    return 0;
+}
+
+int cfe_bc_reset(void)
+{
+    int rv;
+    struct bootcfg_nand_log log;
+
+    bootcfg_open();
+
+    rv = bootcfg_get_last_log(&log);
+    if (rv == BOOTCFG_RC_ERR_LOG_EMPTY)
+    {
+        printf("Bootconfig log is empty\n");
+    }
+    else if (rv != BOOTCFG_RC_OK)
+    {
+        return rv;
+    }
+
+    rv = bootcfg_write_log_reset();
+    if (rv != BOOTCFG_RC_OK)
+    {
+        return rv;
+    }
+
+    return 0;
+}
+
+int cfe_bc_write_ignore_skip(enum bootcfg_location loc)
+{
+    int rv;
+    struct bootcfg_nand_log log;
+
+    bootcfg_open();
+
+    rv = bootcfg_get_last_log(&log);
+    if (rv == BOOTCFG_RC_ERR_LOG_EMPTY)
+    {
+        printf("Bootconfig log is empty\n");
+    }
+    else if (rv != BOOTCFG_RC_OK)
+    {
+        return rv;
+    }
+
+    rv = bootcfg_set_ignore_skip_img(loc);
+    if (rv != BOOTCFG_RC_OK)
+    {
+        return rv;
+    }
+
+    return 0;
+}
+
+
+/**
+ * Bootconfig
+ */
+
+
+#ifndef MIN
+#define MIN(a,b) \
+    ({ __typeof__ (a) _a = (a); \
+    __typeof__ (b) _b = (b); \
+    _a < _b ? _a : _b; })
+#endif
+
+
+//#define DEBUG
+
+#ifdef DEBUG
+    #define LOGD(fmt, ...) printf(fmt "\n", ##__VA_ARGS__)
+#else
+    #define LOGD(fmt, ...)
+#endif
+
+#define LOGI(fmt, ...) printf(fmt "\n", ##__VA_ARGS__)
+#define LOGE(fmt, ...) printf(fmt "\n", ##__VA_ARGS__)
+
+
+static struct bootcfg_info bc_info;
+
+
+static void get_sector_from_offset(off_t off, unsigned short *sector, int *sector_offset)
+{
+    off += bc_info.part_off;
+
+    *sector = off / bc_info.part_erasesize;
+    *sector_offset = off % bc_info.part_erasesize;
+}
+
+static int fd_read(off_t off, void *data, ssize_t len)
+{
+    int rv;
+    unsigned short sector;
+    int sector_offset;
+
+    get_sector_from_offset(off, &sector, &sector_offset);
+
+    rv = flash_read_buf(sector, sector_offset, data, len);
+    if (rv != len)
+    {
+        LOGE("Could not read data; sector: %d; sector_off: %d; len: 0x%04x",
+            sector, sector_offset, len);
+        return BOOTCFG_RC_ERR_READ;
+    }
+
+    return BOOTCFG_RC_OK;
+}
+
+static int fd_write(off_t off, void *data, ssize_t len)
+{
+    int rv;
+    unsigned short sector;
+    int sector_offset;
+
+    get_sector_from_offset(off, &sector, &sector_offset);
+
+    rv = flash_write_buf(sector, sector_offset, data, len);
+    if (rv != len)
+    {
+        LOGE("Could not write data; sector: %d; sector_off: %d; len: 0x%04x",
+            sector, sector_offset, len);
+        return BOOTCFG_RC_ERR_WRITE;
+    }
+
+    return BOOTCFG_RC_OK;
+}
+
+static int fd_erase(off_t off)
+{
+    int rv;
+    unsigned short sector;
+    int sector_offset;
+
+    get_sector_from_offset(off, &sector, &sector_offset);
+
+    rv = flash_sector_erase_int(sector);
+    if (rv != FLASH_API_OK) {
+        LOGE("Could not erase sector; sector: %d", sector);
+        return BOOTCFG_RC_ERR_ERASE;
+    }
+
+    return BOOTCFG_RC_OK;
+}
+
+static bool memcmp_b(const uint8_t * buff, uint8_t value, ssize_t sz)
+{
+    ssize_t i = 0;
+    bool cmp = true;
+
+    while (i < sz)
+    {
+        if (buff[i++] != value)
+        {
+            cmp = false;
+            break;      /* while    */
+        }
+    }
+
+    return cmp;
+}
+
+static void calc_extra_part_layout(struct bc_part_layout *parts, int parts_num)
+{
+    int i;
+    ssize_t extra = 0;
+
+    parts[parts_num-1].offset = NVRAM.ulNandPartOfsKb[NP_DATA] * 1024;
+    parts[parts_num-1].size = NVRAM.ulNandPartSizeKb[NP_DATA] * 1024;
+
+    /* skip the /data partition */
+    for (i = BCM_MAX_EXTRA_PARTITIONS - 2; i >= 0; i--)
+    {
+        ssize_t extra_part_size = convert_to_data_partition_entry_to_bytes(NVRAM.part_info[i].size);
+
+        extra += extra_part_size;
+        parts[i].size = extra_part_size;
+        parts[i].offset = parts[parts_num-1].offset - extra;
+    }
+}
+
+
+static void get_nand_flash_info(struct bootcfg_info *info, uint32_t part_idx)
+{
+    struct bc_part_layout extra_parts[BCM_MAX_EXTRA_PARTITIONS];
+
+    info->part_erasesize = flash_get_sector_size(0);
+    /* TODO: how do we get this programmatically */
+    info->part_writesize = 2048;
+
+    calc_extra_part_layout(extra_parts, BCM_MAX_EXTRA_PARTITIONS);
+
+    info->part_size = extra_parts[part_idx].size;
+    info->part_off = extra_parts[part_idx].offset;
+}
+
+static int location_to_index(enum bootcfg_location loc)
+{
+    if (loc == BOOTCFG_LOC_1)
+    {
+        return 0;
+    }
+    else if (loc == BOOTCFG_LOC_2)
+    {
+        return 1;
+    }
+
+    LOGE("Bootconfig location not recognized: %d", loc);
+    return -1;
+}
+
+
+static uint32_t calc_crc(struct bootcfg_nand_log *log)
+{
+    /* crc field is located at the end of the log structure, and is of type uint32_t */
+    return ~lib_get_crc32((void *)log, sizeof(*log)-sizeof(uint32_t), 0xFFFFFFFFUL);
+}
+
+
+static int verify_flash(off_t start_off, uint8_t *data, ssize_t datalen)
+{
+    uint8_t buf[256];
+    off_t off = start_off;
+    off_t end_off = start_off + datalen;
+
+    LOGD("%s; 0x%08lx:0x%08x", __func__, start_off, datalen);
+
+    while (off < end_off)
+    {
+        ssize_t rem = MIN(datalen, (ssize_t)sizeof(buf));
+        int rv;
+
+        rv = fd_read(off, buf, rem);
+        if (rv != BOOTCFG_RC_OK)
+        {
+            return rv;
+        }
+
+        if (memcmp(data, buf, rem) != 0)
+        {
+            LOGE("Verification failed; off: 0x%08lx", off);
+            return BOOTCFG_RC_ERR_VERIFY;
+        }
+
+        data += rem;
+        datalen -= rem;
+        off += rem;
+    }
+
+    return BOOTCFG_RC_OK;
+}
+
+static int sector_verify_erase(off_t start_off, ssize_t erasesize)
+{
+    uint8_t buf[256];
+    off_t off = start_off;
+    off_t end_off = start_off + erasesize;
+
+    LOGD("%s; 0x%08lx:0x%04x", __func__, start_off, erasesize);
+
+    while (off < end_off)
+    {
+        ssize_t rem = MIN(erasesize, (ssize_t)sizeof(buf));
+        int rv;
+
+        rv = fd_read(off, buf, rem);
+        if (rv != BOOTCFG_RC_OK)
+        {
+            return rv;
+        }
+
+        if (memcmp_b(buf, 0xFF, rem) != true)
+        {
+            /*LOGE("Sector failed to erase properly; off: 0x%04x", (uint32_t)off);*/
+            return BOOTCFG_RC_ERR_ERASE;
+        }
+
+        off += rem;
+        erasesize -= rem;
+    }
+
+    return BOOTCFG_RC_OK;
+}
+
+static int sector_erase(off_t off, ssize_t erasesize)
+{
+    int rv;
+
+    LOGD("%s; 0x%08lx", __func__, off);
+
+    rv = fd_erase(off);
+    if (rv != BOOTCFG_RC_OK)
+    {
+        return rv;
+    }
+
+    rv = sector_verify_erase(off, erasesize);
+    if (rv != BOOTCFG_RC_OK)
+    {
+        return rv;
+    }
+
+    return BOOTCFG_RC_OK;
+}
+
+static int read_log(off_t off, struct bootcfg_nand_log *log)
+{
+    int rv;
+
+    rv = fd_read(off, log, sizeof(*log));
+    if (rv != BOOTCFG_RC_OK)
+    {
+        return rv;
+    }
+
+    if (memcmp_b((void *)log, 0xFF, sizeof(*log)) == true)
+    {
+        /*LOGD("Log: 0x%08lx empty", off);*/
+        return BOOTCFG_RC_ERR_LOG_EMPTY;
+    }
+
+    if (log->magic != BOOTCFG_MAGIC)
+    {
+        LOGE("Log magic incorrect: 0x%08lx, 0x%08x", off, log->magic);
+        return BOOTCFG_RC_ERR_MAGIC;
+    }
+
+    if (calc_crc(log) != log->crc)
+    {
+        LOGE("Log checksum incorrect: 0x%08lx, 0x%08x, 0x%08x", off, calc_crc(log), log->crc);
+        return BOOTCFG_RC_ERR_CHKSUM;
+    }
+
+    return BOOTCFG_RC_OK;
+}
+
+static int write_log(struct bootcfg_nand_log *log, off_t off, ssize_t pagesize)
+{
+    int rv;
+
+    LOGD("%s; writing to 0x%08lx", __func__, off);
+
+    rv = fd_write(off, log, pagesize);
+    if (rv != BOOTCFG_RC_OK)
+    {
+        return rv;
+    }
+
+    if (verify_flash(off, (void *)log, sizeof(*log)) != BOOTCFG_RC_OK)
+    {
+        LOGE("Read-back verification failed");
+        return BOOTCFG_RC_ERR_VERIFY;
+    }
+
+    return BOOTCFG_RC_OK;
+}
+
+static int bootcfg_write_log(struct bootcfg_info *info)
+{
+    int rv;
+    struct bootcfg_nand_log *log = info->last_log;
+    off_t off = info->off_next_log;
+    int retries = info->part_size / info->part_erasesize; /* number of erase sectors */
+
+
+    if (info->part_size == 0) {
+        LOGE("Bootconfig partition does not exist; abort bootconfig");
+        return BOOTCFG_RC_ERR;
+    }
+
+    log->magic = BOOTCFG_MAGIC;
+    log->uid++;
+    log->crc = calc_crc(log);
+
+restart:
+    if (retries-- == 0) {
+        LOGE("Could not write log; max retries reached");
+        return BOOTCFG_RC_ERR_WRITE;
+    }
+
+    LOGD("Trying to write log to off: 0x%08lx", off);
+
+    if ((off % (off_t)info->part_erasesize) == 0)
+    {
+        /* we are about to write to the next sector; check if it is erased */
+
+        if (off >= (off_t)info->part_size)
+        {
+            /* we are at the end of partition; go back to beginning */
+            LOGI("Crossing over to the start of the partition");
+            off = 0;
+        }
+
+        rv = sector_verify_erase(off, info->part_erasesize);
+        if (rv != BOOTCFG_RC_OK)
+        {
+            LOGD("Sector is not erased; erasing; 0x%08lx", off);
+            /* sector is not erased; erase it */
+            rv = sector_erase(off, info->part_erasesize);
+            if (rv < 0)
+            {
+                LOGD("Sector failed to erase; restarting; 0x%08lx", off);
+                /* erasing/verification of erase failed; could be a bad block */
+                /* go to next erase sector */
+                off += info->part_erasesize;
+                goto restart;
+            }
+        }
+    }
+
+    /* check that the part_writesize is erased */
+    rv = sector_verify_erase(off, info->part_writesize);
+    if (rv != BOOTCFG_RC_OK)
+    {
+        /* sector is not erased; go to next erase sector */
+        LOGI("Write page is not erased; restarting; off: 0x%08lx", off);
+        off = off - (off % (off_t)info->part_erasesize) + info->part_erasesize;
+        goto restart;
+    }
+
+    rv = write_log(log, off, info->part_writesize);
+    if (rv < 0)
+    {
+        /* writing failed; could be a bad block; try to repeat; go to next erase sector */
+        LOGE("Writing log failed; restarting; off: 0x%08lx", off);
+        off = off - (off % (off_t)info->part_erasesize) + info->part_erasesize;
+        goto restart;
+    }
+
+    /* write success; store pointer to the next log */
+    info->off_next_log = off + info->part_writesize;
+
+    return BOOTCFG_RC_OK;
+}
+
+
+
+/**
+ * Open the interface to the bootconfig, retrieve info about flash partition
+ * size and geometry.
+ */
+int bootcfg_open(void)
+{
+    LOGD("%s", __func__);
+
+    get_nand_flash_info(&bc_info, 2/*misc3*/);
+
+    memset(bc_info.log_buf, 0xFF, sizeof(bc_info.log_buf));
+    bc_info.last_log = (struct bootcfg_nand_log *)bc_info.log_buf;
+
+    return BOOTCFG_RC_OK;
+}
+
+/**
+ * Reset the bootconfig info for both images. Typically called after
+ * TFTP recovery.
+ */
+int bootcfg_write_log_reset(void)
+{
+    int rv;
+
+    LOGD("%s", __func__);
+
+    bc_info.last_log->img[0].skip = 0xFFFFFFFFUL;
+    bc_info.last_log->img[1].skip = 0xFFFFFFFFUL;
+    bc_info.last_log->img[0].ignore_skip = 0xFFFFFFFFUL;
+    bc_info.last_log->img[1].ignore_skip = 0xFFFFFFFFUL;
+    bc_info.last_log->img[0].cnt_current = 0;
+    bc_info.last_log->img[1].cnt_current = 0;
+    bc_info.last_log->img[0].cnt_all_success = 0;
+    bc_info.last_log->img[1].cnt_all_success = 0;
+
+    rv = bootcfg_write_log(&bc_info);
+    if (rv < 0)
+    {
+        LOGE("Could not write log");
+        return rv;
+    }
+
+    return BOOTCFG_RC_OK;
+}
+
+/**
+ * Write a new bootconfig log with source of boot set as bootloader.
+ */
+int bootcfg_write_log_btldr(enum bootcfg_location location)
+{
+    int rv;
+    int loc;
+
+    LOGD("%s", __func__);
+
+    loc = location_to_index(location);
+    if (loc == -1)
+    {
+        return BOOTCFG_RC_ERR;
+    }
+
+    bc_info.last_log->cnt_all_boots++;
+    bc_info.last_log->img[loc].cnt_current++;
+
+    if (bc_info.last_log->img[loc].cnt_current >= bc_info.last_log->img[loc].cnt_threshold)
+    {
+        LOGI("WARNING: bootcfg bad count threshold reached");
+        bc_info.last_log->img[loc].skip = 0x00000000UL;
+    }
+
+    rv = bootcfg_write_log(&bc_info);
+    if (rv < 0)
+    {
+        LOGE("Could not write log");
+        return rv;
+    }
+
+    return BOOTCFG_RC_OK;
+}
+
+/**
+ * Write a new bootconfig log with 'skip image' flag set for specified image location.
+ */
+#if 0
+int bootcfg_set_skip_img(enum bootcfg_location location)
+{
+    int rv;
+    int loc;
+
+    LOGD("%s", __func__);
+
+    loc = location_to_index(location);
+    if (loc == -1)
+    {
+        return BOOTCFG_RC_ERR;
+    }
+
+    bc_info.last_log->img[loc].skip = 0x00000000UL;
+
+    rv = bootcfg_write_log(&bc_info);
+    if (rv < 0)
+    {
+        LOGE("Could not write log");
+        return rv;
+    }
+
+    return BOOTCFG_RC_OK;
+}
+#endif
+
+/**
+ * Write a new bootconfig log with 'ignore skip image' flag set for specified image location.
+ */
+int bootcfg_set_ignore_skip_img(enum bootcfg_location location)
+{
+    int rv;
+    int loc;
+
+    LOGD("%s", __func__);
+
+    loc = location_to_index(location);
+    if (loc == -1)
+    {
+        return BOOTCFG_RC_ERR;
+    }
+
+    bc_info.last_log->img[loc].ignore_skip = 0x00000000UL;
+
+    rv = bootcfg_write_log(&bc_info);
+    if (rv < 0)
+    {
+        LOGE("Could not write log");
+        return rv;
+    }
+
+    return BOOTCFG_RC_OK;
+}
+
+/**
+ * Find and return the latest boot log
+ */
+int bootcfg_get_last_log(struct bootcfg_nand_log *log)
+{
+    int rv;
+    off_t off;
+    struct bootcfg_nand_log tmp;
+
+    LOGD("%s", __func__);
+
+    off_t off_last_log = 0;
+    uint64_t last_log_uid = 0;
+    bool is_empty = true;
+
+    if (bc_info.part_size == 0) {
+        LOGE("Bootconfig partition does not exist; abort bootconfig");
+        return BOOTCFG_RC_ERR;
+    }
+
+    off = 0;
+    while (off < bc_info.part_size)
+    {
+        rv = read_log(off, &tmp);
+        if (rv == BOOTCFG_RC_OK)
+        {
+            if (tmp.uid > last_log_uid)
+            {
+                /* ok, store current offset, and uid */
+                last_log_uid = tmp.uid;
+                off_last_log = off;
+            }
+
+            off += bc_info.part_writesize;
+            is_empty = false;
+        }
+        else if ((rv == BOOTCFG_RC_ERR_CHKSUM) || (rv == BOOTCFG_RC_ERR_MAGIC))
+        {
+            /* checksum or magic is wrong */
+            off += bc_info.part_writesize;
+            is_empty = false;
+        }
+        else if (rv == BOOTCFG_RC_ERR_LOG_EMPTY)
+        {
+            /* skip to the beginning of the next sector */
+            off = off - (off % bc_info.part_erasesize) + bc_info.part_erasesize;
+        }
+        else
+        {
+            /* unknown error; abort */
+            return rv;
+        }
+    }
+
+    rv = read_log(off_last_log, bc_info.last_log);
+    if ((rv != BOOTCFG_RC_OK) || (is_empty == true))
+    {
+        LOGD("Log is empty, set defaults");
+
+        bc_info.last_log->magic = BOOTCFG_MAGIC;
+        bc_info.last_log->uid = 0;
+        bc_info.last_log->cnt_all_boots = 0;
+        bc_info.last_log->cnt_all_success = 0;
+
+        bc_info.last_log->img[0].cnt_current = 0;
+        bc_info.last_log->img[0].cnt_all_success = 0;
+        bc_info.last_log->img[0].cnt_threshold = BOOTCFG_BADCOUNT_THRESHOLD;
+        bc_info.last_log->img[0].skip = 0xFFFFFFFFUL;
+        bc_info.last_log->img[0].ignore_skip = 0xFFFFFFFFUL;
+
+        bc_info.last_log->img[1].cnt_current = 0;
+        bc_info.last_log->img[1].cnt_all_success = 0;
+        bc_info.last_log->img[1].cnt_threshold = BOOTCFG_BADCOUNT_THRESHOLD;
+        bc_info.last_log->img[1].skip = 0xFFFFFFFFUL;
+        bc_info.last_log->img[1].ignore_skip = 0xFFFFFFFFUL;
+
+        bc_info.off_next_log = 0;
+
+        rv = BOOTCFG_RC_ERR_LOG_EMPTY;
+    }
+    else {
+        bc_info.off_next_log = off_last_log + bc_info.part_writesize;
+    }
+
+    if (log != NULL) {
+        memcpy(log, bc_info.last_log, sizeof(*log));
+    }
+
+    return rv;
+}
+
+
+void bootcfg_dump_log(struct bootcfg_nand_log *log)
+{
+    LOGI("Bootconfig last log: uid:%llu; all:%u; all_success:%u",
+        log->uid, log->cnt_all_boots, log->cnt_all_success);
+    LOGI("Img1 curr:%u; all:%u; thrld:%u; skip:0x%x; ign_skip:0x%x",
+        log->img[0].cnt_current, log->img[0].cnt_all_success, log->img[0].cnt_threshold,
+        log->img[0].skip, log->img[0].ignore_skip);
+    LOGI("Img2 curr:%u; all:%u; thrld:%u; skip:0x%x; ign_skip:0x%x",
+        log->img[1].cnt_current, log->img[1].cnt_all_success, log->img[1].cnt_threshold,
+        log->img[1].skip, log->img[1].ignore_skip);
+}
--- a/make.common
+++ b/make.common
@@ -647,6 +647,10 @@ unexport LS_COLORS
 
 export DESKTOP_LINUX BRCM_BOARD BRCM_UCLIBC
 
+# these vars are needed by CFE RAM
+export BUILD_BOOTCONFIG
+export BUILD_BOOTCONFIG_RECOVERY_FILENAME
+
 # update profile BCM_WLIMPL if overridden from CLI
 ifneq ($(strip $(WLIMPL)),)
 export BCM_WLIMPL := $(WLIMPL)
--- a/targets/config.in
+++ b/targets/config.in
@@ -2823,6 +2823,8 @@ if [ "$BUILD_OPENSYNC" = "y" ]; then
     define_bool BUILD_LIBCURL "y"
     define_bool BUILD_LIBCURL_WITH_SSL "y"
 fi
+bool "enable Plume bootconfig in CFE RAM" BUILD_BOOTCONFIG
+string "set Plume bootconfig recovery image file name" BUILD_BOOTCONFIG_RECOVERY_FILENAME
 if [ "$BRCM_BOARD_ID" = "96755pathos" ]; then define_string TARGET "PATHOS_BCM52"; fi
 
 endmenu
