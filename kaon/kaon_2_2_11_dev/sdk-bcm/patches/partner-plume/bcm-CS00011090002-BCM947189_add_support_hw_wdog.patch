--- a/kernel/dts/47189/947189.dts
+++ b/kernel/dts/47189/947189.dts
@@ -94,6 +94,12 @@
 			};
 		};
 
+		watchdog@80 {
+			compatible = "brcm,bcm96xxx-wdt";
+			reg = <0x80 0x4>;
+			timeout-sec = <80>;
+		};
+
 #if (CONFIG_BCM_ENET_IMPL == 7)
 		enetcore0@5000 {
 			compatible = "bcmenet0";
--- a/kernel/linux-4.1/drivers/watchdog/bcm96xxx_wdt.c
+++ b/kernel/linux-4.1/drivers/watchdog/bcm96xxx_wdt.c
@@ -58,8 +58,13 @@
 /* Watchdog soft reset register (BCM6328 only) */
 #define WDT_SOFTRESET_REG		0xc
 
+#if !defined(CONFIG_BCM947189)
 #define WDT_HZ				50000000 /* Fclk */
 #define WDT_MAX_TIME_TICKS		0xffffffff
+#else
+#define WDT_HZ				32000 /* 32KHz clock */
+#define WDT_MAX_TIME_TICKS		0xfffffff /* 28-bit counter */
+#endif
 #define WDT_DEFAULT_TIME_SECS		10
 
 #define SECS_TO_WDOG_TICKS(x) ((uint32_t)((x) * WDT_HZ))
@@ -80,8 +85,10 @@ static int bcm96xxx_wdt_start(struct wat
 	spin_lock_irqsave(&wdt->lock, flags);
 
 	writel_relaxed(SECS_TO_WDOG_TICKS(wdog->timeout),  wdt->base + WDT_DEFVAL_REG);
+#if !defined(CONFIG_BCM947189)
 	writel_relaxed(WDT_START_1, wdt->base + WDT_CTL_REG);
 	writel_relaxed(WDT_START_2, wdt->base + WDT_CTL_REG);
+#endif
 
 	spin_unlock_irqrestore(&wdt->lock, flags);
 
@@ -92,8 +99,13 @@ static int bcm96xxx_wdt_stop(struct watc
 {
 	struct bcm96xxx_wdt *wdt = watchdog_get_drvdata(wdog);
 
+#if !defined(CONFIG_BCM947189)
 	writel_relaxed(WDT_STOP_1, wdt->base + WDT_CTL_REG);
 	writel_relaxed(WDT_STOP_2, wdt->base + WDT_CTL_REG);
+#else
+	/* write 0 to stop WDT */
+	writel_relaxed(0,  wdt->base + WDT_DEFVAL_REG);
+#endif
 
 	dev_info(wdog->dev, "Watchdog timer stopped");
 	return 0;
