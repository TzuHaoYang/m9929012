ESW-2365: enet: remove code for parsing ethernet frames with additional ethernet type prepended

We do not expect Broadcom specific events to be transmitted via ethernet.
--- a/bcmdrivers/opensource/net/enet/impl5/bcmenet.c
+++ b/bcmdrivers/opensource/net/enet/impl5/bcmenet.c
@@ -158,7 +158,6 @@ static void __exit bcmenet_module_cleanu
 static int __init bcmenet_module_init(void);
 static int bcm63xx_enet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 int __init bcm63xx_enet_probe(void);
-static int bcm_mvtags_len(char *ethHdr);
 static void bcmenet_update_pbvlan_all_bridge(void);
 
 /* Sanity checks for user configured DMA parameters */
@@ -684,119 +683,6 @@ static int create_vport(void)
     return 0;
 }
 
-#undef OFFSETOF
-#define OFFSETOF(STYPE, MEMBER)     ((size_t) &((STYPE *)0)->MEMBER)
-
-static inline int bcm_mvtags_len(char *ethHdr)
-{
-    unsigned int end_offset = 0;
-    struct vlan_ethhdr *vhd;
-    BcmEnet_hdr* bhd;
-    uint16 brcm_type;
-
-    bhd = (BcmEnet_hdr*)ethHdr;
-    brcm_type = ntohs(bhd->brcm_type);
-    if (brcm_type == BRCM_TYPE)
-    {
-        end_offset += BRCM_TAG_LEN;
-        bhd = (BcmEnet_hdr *)((uintptr_t)bhd + BRCM_TAG_LEN);
-        brcm_type = ntohs(bhd->brcm_type);
-    }
-
-    /* FTTDP inband control traffic also uses 0x888A, but is not a switch tag. Assume they don't exist together */
-    if (brcm_type == BRCM_TYPE2)
-    {
-        end_offset += BRCM_TAG_TYPE2_LEN;
-    }
-
-#ifdef VLAN_TAG_FFF_STRIP
-    vhd = (struct vlan_ethhdr*)(ethHdr + end_offset);
-    if((ntohs(vhd->h_vlan_proto) == VLAN_TYPE) &&
-            (ntohs(vhd->h_vlan_TCI) & VLAN_VID_MASK) == 0xFFF)
-    {
-        end_offset += VLAN_HLEN;
-    }
-#endif
-
-    return end_offset;
-}
-
-/*
- *  This is a modified version of eth_type_trans(), for taking care of
- *  Broadcom Tag with Ethernet type BRCM_TYPE [0x8874].
- */
-
-unsigned short bcm_type_trans(struct sk_buff *skb, struct net_device *dev)
-{
-    struct ethhdr *eth;
-    unsigned char *rawp;
-    unsigned int end_offset = 0, from_offset = 0;
-    uint16 *to, *end, *from;
-    unsigned int hdrlen = sizeof(struct ethhdr);
-
-    skb_reset_mac_header(skb);
-
-    end_offset = bcm_mvtags_len(skb->data);
-    if (end_offset)
-    {
-        from_offset = OFFSETOF(struct ethhdr, h_proto);
-
-        to = (uint16*)(skb->data + from_offset + end_offset) - 1;
-        end = (uint16*)(skb->data + end_offset) - 1;
-        from = (uint16*)(skb->data + from_offset) - 1;
-
-        while ( to != end )
-            *to-- = *from--;
-    }
-
-    skb_set_mac_header(skb, end_offset);
-
-    hdrlen += end_offset;
-
-    skb_pull(skb, hdrlen);
-    eth = (struct ethhdr *)skb_mac_header(skb);
-
-    if(*eth->h_dest&1)
-    {
-        if(memcmp(eth->h_dest,dev->broadcast, ETH_ALEN)==0)
-            skb->pkt_type=PACKET_BROADCAST;
-        else
-            skb->pkt_type=PACKET_MULTICAST;
-    }
-
-    /*
-     *  This ALLMULTI check should be redundant by 1.4
-     *  so don't forget to remove it.
-     *
-     *  Seems, you forgot to remove it. All silly devices
-     *  seems to set IFF_PROMISC.
-     */
-
-    else if(1 /*dev->flags&IFF_PROMISC*/)
-    {
-        if(memcmp(eth->h_dest,dev->dev_addr, ETH_ALEN))
-            skb->pkt_type=PACKET_OTHERHOST;
-    }
-
-    if (ntohs(eth->h_proto) >= 1536)
-        return eth->h_proto;
-
-    rawp = skb->data;
-
-    /*
-     *  This is a magic hack to spot IPX packets. Older Novell breaks
-     *  the protocol design and runs IPX over 802.3 without an 802.2 LLC
-     *  layer. We look for FFFF which isn't a used 802.2 SSAP/DSAP. This
-     *  won't work for fault tolerant netware but does for the rest.
-     */
-    if (*(unsigned short *)rawp == 0xFFFF)
-        return htons(ETH_P_802_3);
-
-    /*
-     *  Real 802.2 LLC
-     */
-    return htons(ETH_P_802_2);
-}
 
 /* --------------------------------------------------------------------------
 Name: bcm63xx_enet_open
@@ -2250,8 +2136,7 @@ static uint32 bcm63xx_rx(void *ptr, uint
             goto next_rx;
         }
 
-        skb->protocol = bcm_type_trans(skb, dev);
-        skb->dev = dev;
+        skb->protocol = eth_type_trans(skb, dev);
 
 #if defined(CONFIG_BCM_CSO)
         if(pFkb->rx_csum_verified)
