--- a/netio.c
+++ b/netio.c
@@ -4,6 +4,8 @@
 #include "session.h"
 #include "debug.h"
 
+#include <net/if.h>
+
 struct dropbear_progress_connection {
 	struct addrinfo *res;
 	struct addrinfo *res_iter;
@@ -429,6 +431,58 @@ int get_sock_port(int sock) {
 	return atoi(strport);
 }
 
+/*
+ * Returns >0 if "name" is an interface name
+ */
+int is_netif(const char* name)
+{
+    struct ifreq    req;
+
+    int             so = -1;
+    int             retval = 0;
+
+    memset(&req, 0, sizeof(req));
+
+    if (strlen(name) >= IFNAMSIZ)
+    {
+        goto error;
+    }
+
+    strcpy(req.ifr_name, name);
+
+    /*
+     * Open an AF_INET type socket; we'll use this file descriptor to do ioctl()s
+     */
+    so = socket(AF_INET, SOCK_DGRAM, 0);
+    if (so < 0)
+    {
+        /* Failed to open socket */
+        goto error;
+    }
+
+    /*
+     * SIOCGIFFLAGS seems to be portable. And doesn't seem to require root privileges.
+     */
+    if (ioctl(so, SIOCGIFFLAGS, &req) != 0)
+    {
+        goto error;
+    }
+
+    /* Interface found, return */
+    retval = 1;
+
+error:
+    /*
+     * Cleanup
+     */
+    if (so >= 0)
+    {
+        close(so);
+    }
+
+    return retval;
+}
+
 /* Listen on address:port. 
  * Special cases are address of "" listening on everything,
  * and address of NULL listening on localhost only.
@@ -444,6 +498,7 @@ int dropbear_listen(const char* address,
 	struct linger linger;
 	int val;
 	int sock;
+	const char *bind_ifname = NULL;
 
 	TRACE(("enter dropbear_listen"))
 	
@@ -464,6 +519,14 @@ int dropbear_listen(const char* address,
 		}
 		hints.ai_flags = AI_PASSIVE;
 	}
+
+	if (address != NULL && is_netif(address))
+	{
+		bind_ifname = address;
+		/* Listen to 0.0.0.0, while binding to a specific interface */
+		address = NULL;
+	}
+
 	err = getaddrinfo(address, port, &hints, &res0);
 
 	if (err) {
@@ -516,6 +579,17 @@ int dropbear_listen(const char* address,
 			continue;
 		}
 
+		if (bind_ifname != NULL)
+		{
+			if (setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE, bind_ifname, strlen(bind_ifname)) != 0)
+			{
+				err = errno;
+				close(sock);
+				TRACE(("setsockopt(SO_BINDTODEVICE) failed: %s", bind_ifname));
+				continue;
+			}
+		}
+
 		/* Various useful socket options */
 		val = 1;
 		/* set to reuse, quick timeout */
