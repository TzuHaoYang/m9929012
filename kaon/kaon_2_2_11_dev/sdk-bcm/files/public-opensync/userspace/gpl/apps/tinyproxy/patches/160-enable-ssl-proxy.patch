---
 src/buffer.c       |   42 +++++++++++++++++---
 src/buffer.h       |    4 -
 src/common.h       |    4 +
 src/conf.c         |    3 -
 src/conns.c        |    6 ++
 src/conns.h        |    6 ++
 src/html-error.c   |    9 +++-
 src/http-message.c |   13 +++---
 src/main.c         |   20 +++++++++
 src/main.h         |    3 +
 src/network.c      |   60 ++++++++++++++++++++++++-----
 src/network.h      |    8 +--
 src/reqs.c         |  108 ++++++++++++++++++++++++++++++++++++-----------------
 src/upstream.c     |    1 
 src/upstream.h     |    1 
 15 files changed, 219 insertions(+), 69 deletions(-)

Index: tinyproxy-1.10.0/src/buffer.c
===================================================================
--- tinyproxy-1.10.0.orig/src/buffer.c
+++ tinyproxy-1.10.0/src/buffer.c
@@ -209,10 +209,18 @@ static struct bufline_s *remove_from_buf
  * Takes a connection and returns the number of bytes read.
  */
 #define READ_BUFFER_SIZE (1024 * 2)
-ssize_t read_buffer (int fd, struct buffer_s * buffptr)
+ssize_t read_buffer (int fd, SSL *ssl_conn, struct buffer_s * buffptr)
 {
         ssize_t bytesin;
         unsigned char *buffer;
+        unsigned int valid_ssl = FALSE;
+
+        if (ssl_conn != NULL) {
+                /* Validate the SSL session. */
+                if (SSL_get_fd(ssl_conn) == fd) {
+                        valid_ssl = TRUE;
+                }
+        }
 
         assert (fd >= 0);
         assert (buffptr != NULL);
@@ -228,7 +236,16 @@ ssize_t read_buffer (int fd, struct buff
                 return -ENOMEM;
         }
 
-        bytesin = read (fd, buffer, READ_BUFFER_SIZE);
+        if (valid_ssl) {
+                bytesin = SSL_read(ssl_conn, buffer, READ_BUFFER_SIZE);
+                if (bytesin <= 0) {
+                        log_message (LOG_ERR,
+                                "read_buffer: bytesin[%d]",bytesin);
+                        return -ENOMEM;
+                }
+        } else {
+                bytesin = read (fd, buffer, READ_BUFFER_SIZE);
+        }
 
         if (bytesin > 0) {
                 if (add_to_buffer (buffptr, buffer, bytesin) < 0) {
@@ -268,10 +285,18 @@ ssize_t read_buffer (int fd, struct buff
  * Write the bytes in the buffer to the socket.
  * Takes a connection and returns the number of bytes written.
  */
-ssize_t write_buffer (int fd, struct buffer_s * buffptr)
+ssize_t write_buffer (int fd, SSL *ssl_conn, struct buffer_s * buffptr)
 {
         ssize_t bytessent;
         struct bufline_s *line;
+        unsigned int valid_ssl = FALSE;
+
+        if (ssl_conn != NULL) {
+                /* Validate the SSL session. */
+                if (SSL_get_fd(ssl_conn) == fd) {
+                        valid_ssl = TRUE;
+                }
+        }
 
         assert (fd >= 0);
         assert (buffptr != NULL);
@@ -283,10 +308,13 @@ ssize_t write_buffer (int fd, struct buf
         assert (BUFFER_HEAD (buffptr) != NULL);
         line = BUFFER_HEAD (buffptr);
 
-        bytessent =
-            send (fd, line->string + line->pos, line->length - line->pos,
-                  MSG_NOSIGNAL);
-
+        if (valid_ssl) {
+        	bytessent = SSL_write(ssl_conn, line->string + line->pos, line->length - line->pos);
+        } else {
+                bytessent =
+                        send (fd, line->string + line->pos, line->length - line->pos,
+                                MSG_NOSIGNAL);
+        }
         if (bytessent >= 0) {
                 /* bytes sent, adjust buffer */
                 line->pos += bytessent;
Index: tinyproxy-1.10.0/src/buffer.h
===================================================================
--- tinyproxy-1.10.0.orig/src/buffer.h
+++ tinyproxy-1.10.0/src/buffer.h
@@ -34,7 +34,7 @@ extern size_t buffer_size (struct buffer
 extern int add_to_buffer (struct buffer_s *buffptr, unsigned char *data,
                           size_t length);
 
-extern ssize_t read_buffer (int fd, struct buffer_s *buffptr);
-extern ssize_t write_buffer (int fd, struct buffer_s *buffptr);
+extern ssize_t read_buffer (int fd, SSL *ssl_conn, struct buffer_s *buffptr);
+extern ssize_t write_buffer (int fd, SSL *ssl_conn, struct buffer_s *buffptr);
 
 #endif /* __BUFFER_H_ */
Index: tinyproxy-1.10.0/src/common.h
===================================================================
--- tinyproxy-1.10.0.orig/src/common.h
+++ tinyproxy-1.10.0/src/common.h
@@ -69,7 +69,9 @@
 #  include	<grp.h>
 #  include	<pwd.h>
 #  include      <regex.h>
-#  include  <pthread.h>
+#  include      <pthread.h>
+#  include      <openssl/ssl.h>
+#  include      <openssl/err.h>
 
 /* rest - some oddball headers */
 #ifdef HAVE_VALUES_H
Index: tinyproxy-1.10.0/src/conf.c
===================================================================
--- tinyproxy-1.10.0.orig/src/conf.c
+++ tinyproxy-1.10.0/src/conf.c
@@ -259,7 +259,7 @@ struct {
                 BEGIN "(upstream)" WS "(none)" WS STR END, handle_upstream_no, NULL
         },
         {
-                BEGIN "(upstream)" WS "(http|socks4|socks5)" WS
+                BEGIN "(upstream)" WS "(http|https|socks4|socks5)" WS
                       "(" USERNAME /*username*/ ":" PASSWORD /*password*/ "@" ")?"
                       "(" IP "|" ALNUM ")"
                       ":" INT "(" WS STR ")?"
@@ -1013,6 +1013,7 @@ static enum proxy_type pt_from_string(co
 	static const char pt_map[][7] = {
 		[PT_NONE]   = "none",
 		[PT_HTTP]   = "http",
+		[PT_HTTPS]   = "https",
 		[PT_SOCKS4] = "socks4",
 		[PT_SOCKS5] = "socks5",
 	};
Index: tinyproxy-1.10.0/src/conns.c
===================================================================
--- tinyproxy-1.10.0.orig/src/conns.c
+++ tinyproxy-1.10.0/src/conns.c
@@ -93,7 +93,9 @@ struct conn_s *initialize_conn (int clie
 
 #ifdef REVERSE_SUPPORT
         connptr->reversepath = NULL;
+        connptr->is_reverse_ssl = FALSE;
 #endif
+        connptr->ssl_conn = NULL;
 
         return connptr;
 
@@ -147,6 +149,10 @@ void destroy_conn (struct conn_s *connpt
         if (connptr->reversepath)
                 safefree (connptr->reversepath);
 #endif
+        if (connptr->ssl_conn) {
+            SSL_shutdown (connptr->ssl_conn);
+            SSL_free (connptr->ssl_conn);
+        }
 
         safefree (connptr);
 
Index: tinyproxy-1.10.0/src/conns.h
===================================================================
--- tinyproxy-1.10.0.orig/src/conns.h
+++ tinyproxy-1.10.0/src/conns.h
@@ -84,12 +84,18 @@ struct conn_s {
          * Place to store the current per-connection reverse proxy path
          */
         char *reversepath;
+	unsigned int is_reverse_ssl;
 #endif
 
         /*
          * Pointer to upstream proxy.
          */
         struct upstream *upstream_proxy;
+
+        /*
+        * SSL related parameters.
+        */
+        SSL *ssl_conn;
 };
 
 /*
Index: tinyproxy-1.10.0/src/html-error.c
===================================================================
--- tinyproxy-1.10.0.orig/src/html-error.c
+++ tinyproxy-1.10.0/src/html-error.c
@@ -110,10 +110,12 @@ send_html_file (FILE *infile, struct con
                                         if (!varval)
                                                 varval = "(unknown)";
                                         r = write_message (connptr->client_fd,
+                                                           connptr->ssl_conn,
                                                            "%s", varval);
                                         in_variable = 0;
                                 } else {
                                         r = write_message (connptr->client_fd,
+                                                           connptr->ssl_conn,
                                                            "%c", *p);
                                 }
 
@@ -136,6 +138,7 @@ send_html_file (FILE *infile, struct con
                         default:
                                 if (!in_variable) {
                                         r = write_message (connptr->client_fd,
+                                                           connptr->ssl_conn,
                                                            "%c", *p);
                                 }
                         }
@@ -176,7 +179,8 @@ int send_http_headers (struct conn_s *co
            a Proxy-Authenticate header field. */
         const char *add = code == 407 ? p_auth_str : (code == 401 ? w_auth_str : "");
 
-        return (write_message (connptr->client_fd, headers,
+        return (write_message (connptr->client_fd, connptr->ssl_conn,
+                               headers,
                                code, message, PACKAGE, VERSION,
                                add));
 }
@@ -208,7 +212,8 @@ int send_http_error_message (struct conn
         error_file = get_html_file (connptr->error_number);
         if (!(infile = fopen (error_file, "r"))) {
                 char *detail = lookup_variable (connptr->error_variables, "detail");
-                return (write_message (connptr->client_fd, fallback_error,
+                return (write_message (connptr->client_fd, connptr->ssl_conn,
+                                       fallback_error,
                                        connptr->error_number,
                                        connptr->error_string,
                                        connptr->error_string,
Index: tinyproxy-1.10.0/src/http-message.c
===================================================================
--- tinyproxy-1.10.0.orig/src/http-message.c
+++ tinyproxy-1.10.0/src/http-message.c
@@ -232,6 +232,7 @@ int http_message_send (http_message_t ms
         char timebuf[30];
         time_t global_time;
         unsigned int i;
+        SSL *ssl_conn = NULL;
 
         assert (is_http_message_valid (msg));
 
@@ -244,28 +245,28 @@ int http_message_send (http_message_t ms
                 return -EINVAL;
 
         /* Write the response line */
-        write_message (fd, "HTTP/1.0 %d %s\r\n",
+        write_message (fd, ssl_conn, "HTTP/1.0 %d %s\r\n",
                        msg->response.code, msg->response.string);
 
         /* Go through all the headers */
         for (i = 0; i != msg->headers.used; ++i)
-                write_message (fd, "%s\r\n", msg->headers.strings[i]);
+                write_message (fd, ssl_conn, "%s\r\n", msg->headers.strings[i]);
 
         /* Output the date */
         global_time = time (NULL);
         strftime (timebuf, sizeof (timebuf), "%a, %d %b %Y %H:%M:%S GMT",
                   gmtime (&global_time));
-        write_message (fd, "Date: %s\r\n", timebuf);
+        write_message (fd, ssl_conn, "Date: %s\r\n", timebuf);
 
         /* Output the content-length */
-        write_message (fd, "Content-length: %u\r\n", msg->body.length);
+        write_message (fd, ssl_conn, "Content-length: %u\r\n", msg->body.length);
 
         /* Write the separator between the headers and body */
-        safe_write (fd, "\r\n", 2);
+        safe_write (fd, ssl_conn, "\r\n", 2);
 
         /* If there's a body, send it! */
         if (msg->body.length > 0)
-                safe_write (fd, msg->body.text, msg->body.length);
+                safe_write (fd, ssl_conn, msg->body.text, msg->body.length);
 
         return 0;
 }
Index: tinyproxy-1.10.0/src/main.c
===================================================================
--- tinyproxy-1.10.0.orig/src/main.c
+++ tinyproxy-1.10.0/src/main.c
@@ -52,6 +52,8 @@ struct config_s *config;
 static struct config_s configs[2];
 static const char* config_file;
 unsigned int received_sighup = FALSE;   /* boolean */
+const SSL_METHOD *method;
+SSL_CTX *ctx;
 
 static struct config_s*
 get_next_config(void)
@@ -263,7 +265,7 @@ int reload_config (int reload_logging)
         if (ret != 0) {
                 goto done;
         }
-
+       
         config = c_next;
 
         if (reload_logging) ret = setup_logging ();
@@ -323,6 +325,22 @@ main (int argc, char **argv)
 
         init_stats ();
 
+        /* Global initialization of SSL libraries */
+        SSL_library_init();
+        OpenSSL_add_all_algorithms();
+        SSL_load_error_strings();
+        method = TLS_client_method();  /* Create new client-method instance */
+        if (!method) {
+                ERR_print_errors_fp(stderr);
+                exit (EX_SOFTWARE);
+        }
+
+        ctx = SSL_CTX_new(method);   /* Create new context */
+        if (!ctx) {
+                ERR_print_errors_fp(stderr);
+                exit (EX_SOFTWARE);
+        }
+
         /* If ANONYMOUS is turned on, make sure that Content-Length is
          * in the list of allowed headers, since it is required in a
          * HTTP/1.0 request. Also add the Content-Type header since it
Index: tinyproxy-1.10.0/src/main.h
===================================================================
--- tinyproxy-1.10.0.orig/src/main.h
+++ tinyproxy-1.10.0/src/main.h
@@ -29,7 +29,10 @@
 #define MAX_IDLE_TIME   (60 * 10)       /* 10 minutes of no activity */
 
 /* Global Structures used in the program */
+
 extern struct config_s *config;
+extern const SSL_METHOD *method;
+extern SSL_CTX *ctx;
 extern unsigned int received_sighup;    /* boolean */
 
 extern int reload_config (int reload_logging);
Index: tinyproxy-1.10.0/src/network.c
===================================================================
--- tinyproxy-1.10.0.orig/src/network.c
+++ tinyproxy-1.10.0/src/network.c
@@ -32,21 +32,30 @@
  * Write the buffer to the socket. If an EINTR occurs, pick up and try
  * again. Keep sending until the buffer has been sent.
  */
-ssize_t safe_write (int fd, const void *buf, size_t count)
+ssize_t safe_write (int fd, SSL *ssl_conn, const void *buf, size_t count)
 {
         ssize_t len;
         size_t bytestosend;
-	const char *buffer = buf;
+        const char *buffer = buf;
+        unsigned int valid_ssl = FALSE;
 
         assert (fd >= 0);
         assert (buffer != NULL);
         assert (count > 0);
 
         bytestosend = count;
+        if (ssl_conn != NULL) {
+                if (SSL_get_fd(ssl_conn) == fd) {
+                        valid_ssl = TRUE;
+                }
+        }
 
         while (1) {
-                len = send (fd, buffer, bytestosend, MSG_NOSIGNAL);
-
+                if (valid_ssl) {
+                        len = SSL_write (ssl_conn, buffer, bytestosend);
+                } else {
+                        len = send (fd, buffer, bytestosend, MSG_NOSIGNAL);
+                }
                 if (len < 0) {
                         if (errno == EINTR)
                                 continue;
@@ -68,12 +77,24 @@ ssize_t safe_write (int fd, const void *
  * Matched pair for safe_write(). If an EINTR occurs, pick up and try
  * again.
  */
-ssize_t safe_read (int fd, void *buffer, size_t count)
+ssize_t safe_read (int fd, SSL *ssl_conn, void *buf, size_t count)
 {
         ssize_t len;
+        unsigned int valid_ssl = FALSE;
+
+        if (ssl_conn != NULL) {
+                /* Validate the SSL session. */
+                if (SSL_get_fd(ssl_conn) == fd) {
+                        valid_ssl = TRUE;
+                }
+        }
 
         do {
-                len = read (fd, buffer, count);
+                if (valid_ssl) {
+                        len = SSL_read(ssl_conn, buf, count);
+                } else {
+                        len = read (fd, buf, count);
+                }
         } while (len < 0 && errno == EINTR);
 
         return len;
@@ -85,7 +106,7 @@ ssize_t safe_read (int fd, void *buffer,
  * was basically stolen from the snprintf() man page of Debian Linux
  * (although I did fix a memory leak. :)
  */
-int write_message (int fd, const char *fmt, ...)
+int write_message (int fd, SSL *ssl_conn, const char *fmt, ...)
 {
         ssize_t n;
         size_t size = (1024 * 8);       /* start with 8 KB and go from there */
@@ -119,7 +140,7 @@ int write_message (int fd, const char *f
                         buf = tmpbuf;
         }
 
-        if (safe_write (fd, buf, n) < 0) {
+        if (safe_write (fd, ssl_conn, buf, n) < 0) {
                 safefree (buf);
                 return -1;
         }
@@ -139,11 +160,12 @@ int write_message (int fd, const char *f
  */
 #define SEGMENT_LEN (512)
 #define MAXIMUM_BUFFER_LENGTH (128 * 1024)
-ssize_t readline (int fd, char **whole_buffer)
+ssize_t readline (int fd, SSL *ssl_conn, char **whole_buffer)
 {
         ssize_t whole_buffer_len;
         char buffer[SEGMENT_LEN];
         char *ptr;
+        unsigned int valid_ssl = FALSE;
 
         ssize_t ret;
         ssize_t diff;
@@ -155,6 +177,13 @@ ssize_t readline (int fd, char **whole_b
         };
         struct read_lines_s *first_line, *line_ptr;
 
+        if (ssl_conn != NULL) {
+                /* Validate the SSL session. */
+                if (SSL_get_fd(ssl_conn) == fd) {
+                        valid_ssl = TRUE;
+                }
+        }
+
         first_line =
             (struct read_lines_s *) safecalloc (sizeof (struct read_lines_s),
                                                 1);
@@ -165,7 +194,11 @@ ssize_t readline (int fd, char **whole_b
 
         whole_buffer_len = 0;
         for (;;) {
-                ret = recv (fd, buffer, SEGMENT_LEN, MSG_PEEK);
+                if (valid_ssl) {
+                        ret = SSL_peek(ssl_conn, buffer, SEGMENT_LEN);
+                } else {
+                        ret = recv (fd, buffer, SEGMENT_LEN, MSG_PEEK);
+                }
                 if (ret <= 0)
                         goto CLEANUP;
 
@@ -192,7 +225,12 @@ ssize_t readline (int fd, char **whole_b
                         goto CLEANUP;
                 }
 
-                ret = recv (fd, line_ptr->data, diff, 0);
+		if (valid_ssl) {
+			ret = SSL_read(ssl_conn, line_ptr->data, diff);
+		} else {
+			ret = recv (fd, line_ptr->data, diff, 0);
+		}
+
                 if (ret == -1) {
                         goto CLEANUP;
                 }
Index: tinyproxy-1.10.0/src/network.h
===================================================================
--- tinyproxy-1.10.0.orig/src/network.h
+++ tinyproxy-1.10.0/src/network.h
@@ -21,11 +21,11 @@
 #ifndef TINYPROXY_NETWORK_H
 #define TINYPROXY_NETWORK_H
 
-extern ssize_t safe_write (int fd, const void *buf, size_t count);
-extern ssize_t safe_read (int fd, void *buf, size_t count);
+extern ssize_t safe_write (int fd, SSL *ssl_conn, const void *buf, size_t count);
+extern ssize_t safe_read (int fd, SSL *ssl_conn, void *buf, size_t count);
 
-extern int write_message (int fd, const char *fmt, ...);
-extern ssize_t readline (int fd, char **whole_buffer);
+extern int write_message (int fd, SSL *ssl_conn, const char *fmt, ...);
+extern ssize_t readline (int fd, SSL *ssl_conn, char **whole_buffer);
 
 extern const char *get_ip_string (struct sockaddr *sa, char *buf, size_t len);
 extern int full_inet_pton (const char *ip, void *dst);
Index: tinyproxy-1.10.0/src/reqs.c
===================================================================
--- tinyproxy-1.10.0.orig/src/reqs.c
+++ tinyproxy-1.10.0/src/reqs.c
@@ -93,7 +93,7 @@ static int read_request_line (struct con
         ssize_t len;
 
 retry:
-        len = readline (connptr->client_fd, &connptr->request_line);
+        len = readline (connptr->client_fd, connptr->ssl_conn, &connptr->request_line);
         if (len <= 0) {
                 log_message (LOG_ERR,
                              "read_request_line: Client (file descriptor: %d) "
@@ -266,6 +266,7 @@ establish_http_connection (struct conn_s
                 /* host is an IPv6 address literal, so surround it with
                  * [] */
                 return write_message (connptr->server_fd,
+                                     connptr->ssl_conn,
                                       "%s %s HTTP/1.0\r\n"
                                       "Host: [%s]%s\r\n"
                                       "Connection: close\r\n",
@@ -275,6 +276,7 @@ establish_http_connection (struct conn_s
                    connptr->upstream_proxy->type == PT_HTTP &&
                    connptr->upstream_proxy->ua.authstr) {
                 return write_message (connptr->server_fd,
+                                      connptr->ssl_conn,
                                       "%s %s HTTP/1.0\r\n"
                                       "Host: %s%s\r\n"
                                       "Connection: close\r\n"
@@ -284,6 +286,7 @@ establish_http_connection (struct conn_s
                                       connptr->upstream_proxy->ua.authstr);
         } else {
                 return write_message (connptr->server_fd,
+                                      connptr->ssl_conn,
                                       "%s %s HTTP/1.0\r\n"
                                       "Host: %s%s\r\n"
                                       "Connection: close\r\n",
@@ -305,6 +308,7 @@ establish_http_connection (struct conn_s
 static int send_ssl_response (struct conn_s *connptr)
 {
         return write_message (connptr->client_fd,
+                              connptr->ssl_conn,
                               "%s\r\n"
                               "%s\r\n"
                               "\r\n", SSL_CONNECTION_RESPONSE, PROXY_AGENT);
@@ -410,7 +414,18 @@ BAD_REQUEST_ERROR:
                                              "url", url, NULL);
                         goto fail;
                 }
-        } else if (strcmp (request->method, "CONNECT") == 0) {
+        } else if (strncasecmp (url, "https://", 8) == 0) {
+                char *skipped_type = strstr (url, "//") + 2;
+
+                if (extract_url (skipped_type, HTTP_PORT_SSL, request) < 0) {
+                        indicate_http_error (connptr, 400, "Bad Request",
+                                             "detail", "Could not parse URL",
+                                             "url", url, NULL);
+                        goto fail;
+                }
+                connptr->is_reverse_ssl = TRUE;
+        }
+        else if (strcmp (request->method, "CONNECT") == 0) {
                 if (extract_url (url, HTTP_PORT_SSL, request) < 0) {
                         indicate_http_error (connptr, 400, "Bad Request",
                                              "detail", "Could not parse URL",
@@ -520,13 +535,13 @@ static int pull_client_data (struct conn
                 return -1;
 
         do {
-                len = safe_read (connptr->client_fd, buffer,
+                len = safe_read (connptr->client_fd, connptr->ssl_conn, buffer,
                                  min (MAXBUFFSIZE, (unsigned long int) length));
                 if (len <= 0)
                         goto ERROR_EXIT;
 
                 if (!connptr->error_variables) {
-                        if (safe_write (connptr->server_fd, buffer, len) < 0)
+                        if (safe_write (connptr->server_fd, connptr->ssl_conn, buffer, len) < 0)
                                 goto ERROR_EXIT;
                 }
 
@@ -586,6 +601,7 @@ static int add_xtinyproxy_header (struct
 {
         assert (connptr && connptr->server_fd >= 0);
         return write_message (connptr->server_fd,
+                              connptr->ssl_conn,
                               "X-Tinyproxy: %s\r\n", connptr->client_ip_addr);
 }
 #endif /* XTINYPROXY */
@@ -599,6 +615,7 @@ static int add_xtinyproxymac_header (str
 {
         assert (connptr && connptr->server_fd >= 0);
         return write_message (connptr->server_fd,
+                              connptr->ssl_conn,
                               "X-Tinyproxy-MAC: %s\r\n", connptr->client_mac_addr);
 }
 #endif /* XTINYPROXYMAC */
@@ -641,7 +658,7 @@ add_header_to_connection (hashmap_t hash
 /*
  * Read all the headers from the stream
  */
-static int get_all_headers (int fd, hashmap_t hashofheaders)
+static int get_all_headers (int fd, SSL *ssl_conn, hashmap_t hashofheaders)
 {
         char *line = NULL;
         char *header = NULL;
@@ -655,7 +672,7 @@ static int get_all_headers (int fd, hash
         assert (hashofheaders != NULL);
 
         for (count = 0; count < MAX_HEADERS; count++) {
-                if ((linelen = readline (fd, &line)) <= 0) {
+                if ((linelen = readline (fd, ssl_conn, &line)) <= 0) {
                         safefree (header);
                         safefree (line);
                         return -1;
@@ -836,6 +853,7 @@ write_via_header (int fd, hashmap_t hash
         len = hashmap_entry_by_key (hashofheaders, "via", (void **) &data);
         if (len > 0) {
                 ret = write_message (fd,
+                                     NULL,
                                      "Via: %s, %hu.%hu %s (%s/%s)\r\n",
                                      data, major, minor, hostname, PACKAGE,
                                      VERSION);
@@ -843,6 +861,7 @@ write_via_header (int fd, hashmap_t hash
                 hashmap_remove (hashofheaders, "via");
         } else {
                 ret = write_message (fd,
+                                     NULL,
                                      "Via: %hu.%hu %s (%s/%s)\r\n",
                                      major, minor, hostname, PACKAGE, VERSION);
         }
@@ -937,6 +956,7 @@ process_client_headers (struct conn_s *c
                             || anonymous_search (config, data) > 0) {
                                 ret =
                                     write_message (connptr->server_fd,
+                                                   connptr->ssl_conn,
                                                    "%s: %s\r\n", data, header);
                                 if (ret < 0) {
                                         indicate_http_error (connptr, 503,
@@ -962,7 +982,7 @@ process_client_headers (struct conn_s *c
 
 
         /* Write the final "blank" line to signify the end of the headers */
-        if (safe_write (connptr->server_fd, "\r\n", 2) < 0)
+        if (safe_write (connptr->server_fd, connptr->ssl_conn, "\r\n", 2) < 0)
                 return -1;
 
         /*
@@ -1005,7 +1025,7 @@ static int process_server_headers (struc
 
         /* Get the response line from the remote server. */
 retry:
-        len = readline (connptr->server_fd, &response_line);
+        len = readline (connptr->server_fd, connptr->ssl_conn, &response_line);
         if (len <= 0)
                 return -1;
 
@@ -1031,7 +1051,7 @@ retry:
         /*
          * Get all the headers from the remote server in a big hash
          */
-        if (get_all_headers (connptr->server_fd, hashofheaders) < 0) {
+        if (get_all_headers (connptr->server_fd, connptr->ssl_conn, hashofheaders) < 0) {
                 log_message (LOG_WARNING,
                              "Could not retrieve all the headers from the remote server.");
                 hashmap_delete (hashofheaders);
@@ -1059,7 +1079,8 @@ retry:
         }
 
         /* Send the saved response line first */
-        ret = write_message (connptr->client_fd, "%s\r\n", response_line);
+        ret = write_message (connptr->client_fd, connptr->ssl_conn, "%s\r\n", response_line);
+
         safefree (response_line);
         if (ret < 0)
                 goto ERROR_EXIT;
@@ -1094,6 +1115,7 @@ retry:
         /* Write tracking cookie for the magical reverse proxy path hack */
         if (config->reversemagic && connptr->reversepath) {
                 ret = write_message (connptr->client_fd,
+                                     connptr->ssl_conn,
                                      "Set-Cookie: " REVERSE_COOKIE
                                      "=%s; path=/\r\n", connptr->reversepath);
                 if (ret < 0)
@@ -1118,6 +1140,7 @@ retry:
                 if (reverse) {
                         ret =
                             write_message (connptr->client_fd,
+                                           connptr->ssl_conn,
                                            "Location: %s%s%s\r\n",
                                            config->reversebaseurl,
                                            (reverse->path + 1), (header + len));
@@ -1143,6 +1166,7 @@ retry:
                                               iter, &data, (void **) &header);
 
                         ret = write_message (connptr->client_fd,
+                                             connptr->ssl_conn,
                                              "%s: %s\r\n", data, header);
                         if (ret < 0)
                                 goto ERROR_EXIT;
@@ -1151,7 +1175,7 @@ retry:
         hashmap_delete (hashofheaders);
 
         /* Write the final blank line to signify the end of the headers */
-        if (safe_write (connptr->client_fd, "\r\n", 2) < 0)
+        if (safe_write (connptr->client_fd, connptr->ssl_conn, "\r\n", 2) < 0)
                 return -1;
 
         return 0;
@@ -1240,7 +1264,7 @@ static void relay_connection (struct con
 
                 if (FD_ISSET (connptr->server_fd, &rset)) {
                         bytes_received =
-                            read_buffer (connptr->server_fd, connptr->sbuffer);
+                            read_buffer (connptr->server_fd, connptr->ssl_conn, connptr->sbuffer);
                         if (bytes_received < 0)
                                 break;
 
@@ -1249,15 +1273,15 @@ static void relay_connection (struct con
                                 break;
                 }
                 if (FD_ISSET (connptr->client_fd, &rset)
-                    && read_buffer (connptr->client_fd, connptr->cbuffer) < 0) {
+                    && read_buffer (connptr->client_fd, connptr->ssl_conn, connptr->cbuffer) < 0) {
                         break;
                 }
                 if (FD_ISSET (connptr->server_fd, &wset)
-                    && write_buffer (connptr->server_fd, connptr->cbuffer) < 0) {
+                    && write_buffer (connptr->server_fd, connptr->ssl_conn, connptr->cbuffer) < 0) {
                         break;
                 }
                 if (FD_ISSET (connptr->client_fd, &wset)
-                    && write_buffer (connptr->client_fd, connptr->sbuffer) < 0) {
+                    && write_buffer (connptr->client_fd, connptr->ssl_conn, connptr->sbuffer) < 0) {
                         break;
                 }
         }
@@ -1275,7 +1299,7 @@ static void relay_connection (struct con
         }
 
         while (buffer_size (connptr->sbuffer) > 0) {
-                if (write_buffer (connptr->client_fd, connptr->sbuffer) < 0)
+                if (write_buffer (connptr->client_fd, connptr->ssl_conn, connptr->sbuffer) < 0)
                         break;
         }
         shutdown (connptr->client_fd, SHUT_WR);
@@ -1292,7 +1316,7 @@ static void relay_connection (struct con
         }
 
         while (buffer_size (connptr->cbuffer) > 0) {
-                if (write_buffer (connptr->server_fd, connptr->cbuffer) < 0)
+                if (write_buffer (connptr->server_fd, connptr->ssl_conn, connptr->cbuffer) < 0)
                         break;
         }
 
@@ -1327,9 +1351,9 @@ connect_to_upstream_proxy(struct conn_s
 		host = gethostbyname(request->host);
 		memcpy(&buff[4], host->h_addr_list[0], 4); /* dest ip */
 		buff[8] = 0; /* user */
-		if (9 != safe_write(connptr->server_fd, buff, 9))
+		if (9 != safe_write(connptr->server_fd, connptr->ssl_conn, buff, 9))
 			return -1;
-		if (8 != safe_read(connptr->server_fd, buff, 8))
+		if (8 != safe_read(connptr->server_fd, connptr->ssl_conn, buff, 8))
 			return -1;
 		if (buff[0]!=0 || buff[1]!=90)
 			return -1;
@@ -1342,9 +1366,9 @@ connect_to_upstream_proxy(struct conn_s
 		buff[1] = n_methods; /* number of methods  */
 		buff[2] = 0; /* no auth method */
 		if (ulen) buff[3] = 2;  /* auth method -> username / password */
-		if (2+n_methods != safe_write(connptr->server_fd, buff, 2+n_methods))
+		if (2+n_methods != safe_write(connptr->server_fd, connptr->ssl_conn, buff, 2+n_methods))
 			return -1;
-		if (2 != safe_read(connptr->server_fd, buff, 2))
+		if (2 != safe_read(connptr->server_fd, connptr->ssl_conn, buff, 2))
 			return -1;
 		if (buff[0] != 5 || (buff[1] != 0 && buff[1] != 2))
 			return -1;
@@ -1365,10 +1389,10 @@ connect_to_upstream_proxy(struct conn_s
 			memcpy(cur, cur_upstream->pass, c);
 			cur += c;
 
-			if((cur - out) != safe_write(connptr->server_fd, out, cur - out))
+			if((cur - out) != safe_write(connptr->server_fd, connptr->ssl_conn, out, cur - out))
 				return -1;
 
-			if(2 != safe_read(connptr->server_fd, in, 2))
+			if(2 != safe_read(connptr->server_fd, connptr->ssl_conn, in, 2))
 				return -1;
 			if(in[1] != 0 || !(in[0] == 5 || in[0] == 1)) {
 				return -1;
@@ -1386,9 +1410,9 @@ connect_to_upstream_proxy(struct conn_s
 		memcpy(&buff[5], request->host, len); /* dest ip */
 		port = htons(request->port);
 		memcpy(&buff[5+len], &port, 2); /* dest port */
-		if (7+len != safe_write(connptr->server_fd, buff, 7+len))
+		if (7+len != safe_write(connptr->server_fd, connptr->ssl_conn, buff, 7+len))
 			return -1;
-		if (4 != safe_read(connptr->server_fd, buff, 4))
+		if (4 != safe_read(connptr->server_fd, connptr->ssl_conn, buff, 4))
 			return -1;
 		if (buff[0]!=5 || buff[1]!=0)
 			return -1;
@@ -1396,17 +1420,25 @@ connect_to_upstream_proxy(struct conn_s
 			case 1: len=4; break; /* ip v4 */
 			case 4: len=16; break; /* ip v6 */
 			case 3: /* domainname */
-				if (1 != safe_read(connptr->server_fd, buff, 1))
+				if (1 != safe_read(connptr->server_fd, connptr->ssl_conn, buff, 1))
 					return -1;
 				len = buff[0]; /* max = 255 */
 				break;
 			default: return -1;
 		}
-		if (2+len != safe_read(connptr->server_fd, buff, 2+len))
+		if (2+len != safe_read(connptr->server_fd, connptr->ssl_conn, buff, 2+len))
 			return -1;
+	} else if (cur_upstream->type == PT_HTTPS) {
+			connptr->ssl_conn = SSL_new(ctx);
+			SSL_set_fd(connptr->ssl_conn, connptr->server_fd);
+			if (SSL_connect(connptr->ssl_conn) == -1) {
+				log_message(LOG_ERR,
+					        "Failed to open SSL connection for file descriptor: %d",
+                                                connptr->server_fd);
+			}
 	} else {
-		return -1;
-	}
+                return -1;
+        }
 
 	if (connptr->connect_method)
 		return 0;
@@ -1458,8 +1490,8 @@ connect_to_upstream (struct conn_s *conn
                 return -1;
         }
 
-	if (cur_upstream->type != PT_HTTP)
-		return connect_to_upstream_proxy(connptr, request);
+        if (cur_upstream->type != PT_HTTP)
+                return connect_to_upstream_proxy(connptr, request);
 
         log_message (LOG_CONN,
                      "Established connection to upstream proxy \"%s\" "
@@ -1521,7 +1553,7 @@ get_request_entity(struct conn_s *connpt
                log_message (LOG_INFO, "no entity");
         } else if (ret == 1 && FD_ISSET (connptr->client_fd, &rset)) {
                 ssize_t nread;
-                nread = read_buffer (connptr->client_fd, connptr->cbuffer);
+                nread = read_buffer (connptr->client_fd, connptr->ssl_conn, connptr->cbuffer);
                 if (nread < 0) {
                         log_message (LOG_ERR,
                                      "Error reading readable client_fd %d",
@@ -1630,7 +1662,7 @@ void handle_connection (int fd, union so
         /*
          * Get all the headers from the client in a big hash.
          */
-        if (get_all_headers (connptr->client_fd, hashofheaders) < 0) {
+        if (get_all_headers (connptr->client_fd, connptr->ssl_conn, hashofheaders) < 0) {
                 log_message (LOG_WARNING,
                              "Could not retrieve all the headers from the client");
                 indicate_http_error (connptr, 400, "Bad Request",
@@ -1705,7 +1737,6 @@ e401:
                 }
                 goto fail;
         }
-
         connptr->upstream_proxy = UPSTREAM_HOST (request->host);
         if (connptr->upstream_proxy != NULL) {
                 if (connect_to_upstream (connptr, request) < 0) {
@@ -1727,6 +1758,15 @@ e401:
                              "Established connection to host \"%s\" using "
                              "file descriptor %d.", request->host,
                              connptr->server_fd);
+                if (connptr->is_reverse_ssl) {
+                        connptr->ssl_conn = SSL_new(ctx);
+                        SSL_set_fd(connptr->ssl_conn, connptr->server_fd);
+                        if (SSL_connect(connptr->ssl_conn) == -1) {
+                                log_message(LOG_ERR,
+                                                "Failed to open SSL connection for fd: %d.",
+                                                connptr->server_fd);
+                        }
+                }
 
                 if (!connptr->connect_method)
                         establish_http_connection (connptr, request);
Index: tinyproxy-1.10.0/src/upstream.h
===================================================================
--- tinyproxy-1.10.0.orig/src/upstream.h
+++ tinyproxy-1.10.0/src/upstream.h
@@ -34,6 +34,7 @@
 typedef enum proxy_type {
 	PT_NONE = 0,
 	PT_HTTP,
+	PT_HTTPS,
 	PT_SOCKS4,
 	PT_SOCKS5
 } proxy_type;
Index: tinyproxy-1.10.0/src/upstream.c
===================================================================
--- tinyproxy-1.10.0.orig/src/upstream.c
+++ tinyproxy-1.10.0/src/upstream.c
@@ -37,6 +37,7 @@ proxy_type_name(proxy_type type)
     switch(type) {
         case PT_NONE: return "none";
         case PT_HTTP: return "http";
+        case PT_HTTPS: return "https";
         case PT_SOCKS4: return "socks4";
         case PT_SOCKS5: return "socks5";
         default: return "unknown";
