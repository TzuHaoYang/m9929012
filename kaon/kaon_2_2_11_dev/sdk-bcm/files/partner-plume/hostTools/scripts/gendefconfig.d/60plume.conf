#!/usr/bin/perl
use strict;
use warnings;
use FindBin qw($Bin);
use lib "$Bin/../../PerlLib";
use BRCM::GenConfig;

# $p will allow us to GET values from the PROFILE
# $c will allow us to SET (and GET and DRIVER_SETUP) on the config
# file as we transform it from a template to the final config

# arguments
# * profile file
# * config  file
my $p    = new BRCM::GenConfig(shift);
my $chip = $p->get('BRCM_CHIP');
my $arch = $p->get('PROFILE_ARCH');

my $c = new BRCM::GenConfig( shift, Chip => $chip, Profile => $p );

############################################################
#          KERNEL FEATURES CONFIGURATION                   #
############################################################

if ($p->get('BRCM_BOARD_ID') =~ /96755pathos/) {
    # GPIO
    $c->set('CONFIG_GPIO_DEVRES', 'y');
    $c->set('CONFIG_GPIOLIB', 'y');
    $c->set('CONFIG_OF_GPIO', 'y');
    $c->set('CONFIG_GPIO_SYSFS', 'y');
    $c->set('CONFIG_GPIO_BCM6755', 'y');

    # fan-rpm hwmon driver; might be changed to use MCU in the future
    $c->set('CONFIG_HWMON', 'y');
    $c->set('CONFIG_HWMON_FAN_RPM', 'y');
    $c->set('CONFIG_PWM', 'y');
    $c->set('CONFIG_PWM_BCM6755', 'y');

    # LEDS
    $c->set('CONFIG_LEDS_PWM', 'y');
    $c->unset('CONFIG_LEDS_TRIGGER_BREATHE');
    $c->set('CONFIG_LEDS_TRIGGER_BREATHE_BCM', 'y');

    # SPI NOR flash
    $c->set('CONFIG_SPI_BCM63XX_HSSPI', 'y');
    $c->set('CONFIG_SPI_SPIDEV', 'y');
    $c->set('CONFIG_MTD_SPI_NOR', 'y');
    $c->set('CONFIG_MTD_M25P80', 'y');
}

if ($p->get('BRCM_BOARD_ID') =~ /96755augustus/) {
    # GPIO
    $c->set('CONFIG_GPIO_DEVRES', 'y');
    $c->set('CONFIG_GPIOLIB', 'y');
    $c->set('CONFIG_OF_GPIO', 'y');
    $c->set('CONFIG_GPIO_SYSFS', 'y');
    $c->set('CONFIG_GPIO_BCM6755', 'y');

    # LEDS
    $c->set('CONFIG_PWM', 'y');
    $c->set('CONFIG_PWM_BCM6755', 'y');
    $c->set('CONFIG_LEDS_PWM', 'y');
    $c->unset('CONFIG_LEDS_TRIGGER_BREATHE');
    $c->set('CONFIG_LEDS_TRIGGER_BREATHE_BCM', 'y');

    # SPI NOR flash
    $c->set('CONFIG_SPI_BCM63XX_HSSPI', 'y');
    $c->set('CONFIG_SPI_SPIDEV', 'y');
    $c->set('CONFIG_MTD_SPI_NOR', 'y');
    $c->set('CONFIG_MTD_M25P80', 'y');

    # Decawave UWB
    $c->set('CONFIG_DECAWAVE_UWB_SPI', 'y');
}

if ($p->get('BRCM_BOARD_ID') =~ /947189cyrus/) {
    # LP5562
    $c->set('CONFIG_I2C', 'y');
    $c->set('CONFIG_LEDS_GPIO_REGISTER', 'y');
    $c->set('CONFIG_LEDS_LP5562', 'y');
    $c->set('CONFIG_FIRMWARE_IN_KERNEL', 'y');
    $c->set('CONFIG_FW_LOADER_USER_HELPER', 'y');
    $c->set('CONFIG_FW_LOADER_USER_HELPER_FALLBACK', 'y');

    # LP5562 can request firmware blobs.
    # I guess this is somehow tied to that?
    $c->unset('CONFIG_UEVENT_HELPER');
    $c->unset('CONFIG_UEVENT_HELPER_PATH');

    # GPIO
    $c->set('CONFIG_GPIOLIB', 'y');
    $c->set('CONFIG_GPIO_DEVRES', 'y');
    $c->set('CONFIG_OF_GPIO', 'y');
    $c->set('CONFIG_DEBUG_GPIO', 'y');
    $c->set('CONFIG_GPIO_SYSFS', 'y');

    # PSTORE
    $c->set('CONFIG_PSTORE_RAM_ADDRESS', '0x0FEC0000');
}

$c->write();
