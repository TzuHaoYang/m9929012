
+++ //depot/CommEngine/patches/WLAN/PATCH_502L07_P1/bcmdrivers/broadcom/char/wlcsm_ext/impl1/src/wlcsm_nvram.c
--- //depot/CommEngine/patches/WLAN/PATCH_502L07_P1/bcmdrivers/broadcom/char/wlcsm_ext/impl1/src/wlcsm_nvram.c

@@ -288,6 +288,11 @@
     return len;
 }
 
+/*
+ * As well as its 'WLAN-driver-internal' buffer of nvram variables, the WLAN driver relies on
+ * nvram variables that are stored outside of the WLAN driver. This function gets called by the WLAN driver
+ * to retrieve those 'external' variables.
+ */
 int wlcsm_nvram_getall(char *buf,int count)
 {
     struct rb_node *node;
@@ -314,6 +319,18 @@
     return len;
 }
 
+/*
+ * This function gets called when kernel-space nvrams have to be transferred to user space. The
+ * kernel nvram buffer can be too large to fit into one ioctl buffer. This function allows reading
+ * of the kernel nvram buffer in multiple 'chunks', by calling this function multiple times.
+ *
+ * @param[in] buf     buffer to write nvram strings into
+ * @param[in] count   *half* the size of buf in [bytes]
+ * @param[in] pos     byte position in a (virtual) bytestream of nvram strings to start reading
+ *                    from
+ * @return            if ret < count : means that subsequent chunks are available
+ *                    if ret >= count: means that final chunk was returned
+ */
 int wlcsm_nvram_getall_pos(char *buf,int count,int pos)
 {
     struct rb_node *node;
@@ -337,11 +354,10 @@
             else
                 tcount+=sprintf(buf+tcount,"%s",tbuf)+1;
         }
+
         if(tcount>count) break;
     }
 
-    tcount = wlcsm_double_null_terminate(buf, count, tcount);
-
     WLCSM_NVRAM_UNLOCK();
     return tcount;
 }
