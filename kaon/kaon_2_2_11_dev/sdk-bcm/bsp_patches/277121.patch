
+++ //depot/CommEngine/patches/WLAN/PATCH_502L07_P1/data-model/cms-dm-tr181-wifi-unfwlcfg.xml
--- //depot/CommEngine/patches/WLAN/PATCH_502L07_P1/data-model/cms-dm-tr181-wifi-unfwlcfg.xml

@@ -244,7 +244,7 @@
   <parameter name="CurrentOperatingChannelBandwidth" type="string" specSource="TR181" profile="Unspecified" requirements="R" supportLevel="ReadOnly" />
     <description source="TRx">The channel bandwidth currently in use. </description>
  
-  <parameter name="ExtensionChannel" type="string" specSource="TR181" profile="Device2_WiFiRadio:1" requirements="W" supportLevel="ReadWrite" defaultValue="BelowControlChannel" validValuesArray="WiFiExtensionControlValues" />
+  <parameter name="ExtensionChannel" type="string" specSource="TR181" profile="Device2_WiFiRadio:1" requirements="W" supportLevel="ReadWrite" defaultValue="Auto" validValuesArray="WiFiExtensionControlValues" />
     <description source="TRx">The secondary extension channel position, applicable when operating in wide channel mode (i.e. when {{param|OperatingChannelBandwidth}} is set to {{enum|40MHz|OperatingChannelBandwidth}} or {{enum|Auto|OperatingChannelBandwidth}}).</description>
 
   <parameter name="GuardInterval" type="string" specSource="TR181" profile="Device2_WiFiRadio:1" requirements="W" supportLevel="ReadWrite" defaultValue="Auto" validValuesArray="WiFiGuardIntervalValues" />

+++ //depot/CommEngine/patches/WLAN/PATCH_502L07_P1/data-model/unfwlcfg/cms-dm-tr181-wifi-unfwlcfg-tags.xml
--- //depot/CommEngine/patches/WLAN/PATCH_502L07_P1/data-model/unfwlcfg/cms-dm-tr181-wifi-unfwlcfg-tags.xml

@@ -63,7 +63,7 @@
   <parameter name="AutoChannelRefreshPeriod" nvram="acs_cs_scan_timer"/>
   <parameter name="SupportedChannelBandwidth" nvram="bw_cap", ntype="int", vmapper="wlbwcap"/>
   <parameter name="OperatingChannelBandwidth" nvram="bw", ntype="int", vmapper="wlbwcap"/>
-  <parameter name="ExtensionChannel" nvram="nctrlsb", ntype="string", vmapper="wlctrlsb"/>
+  <parameter name="ExtensionChannel" nvram="mdmsideband", ntype="string", vmapper="wlctrlsb"/>
   <parameter name="MCS" nvram="nmcsidx"/>
   <parameter name="BeaconPeriod" nvram="bcn"/>
   <parameter name="DTIMPeriod" nvram="dtim"/>

+++ //depot/CommEngine/patches/WLAN/PATCH_502L07_P1/userspace/private/libs/cms_core/linux/device2/rcl2_unfwifi.c
--- //depot/CommEngine/patches/WLAN/PATCH_502L07_P1/userspace/private/libs/cms_core/linux/device2/rcl2_unfwifi.c

@@ -195,20 +195,6 @@
         {
             newObj->autoChannelEnable=0;
         }
-
-        /* Validate control sideband for 2.4G 40MHz */
-        if (strcmp(newObj->operatingChannelBandwidth,MDMVS_40MHZ) == 0 &&
-            strcmp(newObj->operatingFrequencyBand, MDMVS_2_4GHZ) == 0)
-        {
-            if (newObj->channel < 5)
-            {
-                REPLACE_STRING_IF_NOT_EQUAL_FLAGS(newObj->extensionChannel, MDMVS_BELOWCONTROLCHANNEL, mdmLibCtx.allocFlags);
-            }
-            else if (newObj->channel > 7 && newObj->channel <= 14)
-            {
-                REPLACE_STRING_IF_NOT_EQUAL_FLAGS(newObj->extensionChannel, MDMVS_ABOVECONTROLCHANNEL, mdmLibCtx.allocFlags);
-            }
-        }
     }
 
     rut2_sendWifiChange();

+++ //depot/CommEngine/patches/WLAN/PATCH_502L07_P1/userspace/private/libs/wlmdm/src/tr181_special.c
--- //depot/CommEngine/patches/WLAN/PATCH_502L07_P1/userspace/private/libs/wlmdm/src/tr181_special.c

@@ -98,6 +98,10 @@
 static UBOOL8 match_mapbss(const char *nvname);
 static WlmdmRet foreach_mapbss(nvc_for_each_func foreach_func, void *data);
 
+static WlmdmRet set_nctrlsb(const char *nvname, const char *value);
+static WlmdmRet get_nctrlsb(const char *nvname, char *value, size_t size);
+static WlmdmRet foreach_nctrlsb(nvc_for_each_func foreach_func, void *data);
+
 extern CmsRet rutBridge_addFullPathToBridge_dev2(const char *fullPath, const char *brIntfName);
 extern UBOOL8 match_name(const char *pattern, const char *nvname);
 
@@ -144,6 +148,13 @@
     .foreach = foreach_mapbss
 };
 
+ActionSet handle_nctrlsb =
+{
+    .set = set_nctrlsb,
+    .get = get_nctrlsb,
+    .foreach = foreach_nctrlsb
+};
+
 SpecialHandler special_handler_table[] =
 {
     { "lan_wps_oob lan%d_wps_oob", &handle_lan_wps_oob },
@@ -151,6 +162,7 @@
     { "lan_ifname lan%d_ifname", &handle_lan_ifname },
     { "lan_ifnames lan%d_ifnames", &handle_lan_ifnames },
     { "map_bss_names", &handle_mbss_names },
+    { "wl%d_nctrlsb", &handle_nctrlsb },
     { NULL, &handle_mapbss}    /*use its own special match: prefix + suffix*/
 };
 
@@ -442,7 +454,7 @@
             if (ret == WLMDM_OK)
             {
                 cmsLog_debug("conv_set_mapped %s=%s", buf, t);
-                conv_set_mapped((char *)&buf, t);
+                conv_set((char *)&buf, t);
             }
         }
 
@@ -633,7 +645,7 @@
     ret = nvn_gen("nctrlsb", radio_index, -1, (char *)&buf, sizeof(buf));
     if (ret == WLMDM_OK)
     {
-        ret = conv_get_mapped((char *)&buf, (char *)buf_1, sizeof(buf_1));
+        ret = conv_get((char *)&buf, (char *)buf_1, sizeof(buf_1));
         if (ret == WLMDM_OK)
         {
             ret = chanspec_get_sb_index((char *)buf_1);
@@ -1533,3 +1545,222 @@
    return WLMDM_OK;
 }
 
+static WlmdmRet set_nctrlsb(const char *nvname, const char *value)
+{
+    WlmdmRet ret;
+    int radio_index, bssid_index;
+    char buf[32]= {0};
+    
+    ret = nvn_disassemble(nvname, &radio_index, &bssid_index, (char *)&buf, sizeof(buf));
+    if (ret != WLMDM_OK)
+    {
+        cmsLog_error("Failed to parse nvname: %s", nvname);
+        return ret;
+    }
+
+    ret = nvn_gen("mdmsideband", radio_index, -1, (char *)&buf, sizeof(buf));
+    if (ret != WLMDM_OK)
+    {
+        return ret;
+    }
+
+    return conv_set_mapped((char *)&buf, (char *)value);        
+}
+
+
+static WlmdmRet get_nctrlsb(const char *nvname, char *value, size_t size)
+{
+
+    WlmdmRet ret;
+    struct chanspec_t chanspecbuf = {0};
+    struct chanspec_t *chanspec=&chanspecbuf;
+    int radio_index, bssid_index;
+    char buf[32], buf_1[32];
+    char *str = NULL ;
+    int autoChannel = 0;
+    long int b;
+    unsigned int channel = 0;
+
+    assert(nvname);
+    assert(value);
+
+    ret = nvn_disassemble(nvname, &radio_index, &bssid_index, (char *)&buf, sizeof(buf));
+    if (ret != WLMDM_OK)
+    {
+        cmsLog_error("Failed to parse nvname: %s", nvname);
+        return ret;
+    }
+
+    ret = nvn_gen("mdmsideband", radio_index, -1, (char *)&buf, sizeof(buf));
+    if (ret != WLMDM_OK)
+    {
+        return ret;
+    }
+
+    ret = conv_get_mapped((char *)&buf , (char *)value, size);
+    if (ret != WLMDM_OK)
+    {
+        return WLMDM_INVALID_PARAM;    
+    }
+
+    cmsLog_debug("%s=%s", nvname,value);
+
+    if(strcmp(value, "Auto"))
+    { /* Control Sideband != "Auto" */
+        return ret;
+    }
+
+    //Handle Control Sideband == "Auto"
+
+    /* by default use lowest channel as control channel */
+    chanspec->band_width = WL_CHANSPEC_BW_20;
+    chanspec->ctlsb_index = 0;
+
+    cmsLog_debug("Auto Control Sideband : %s=%s", nvname,value);
+
+    do{
+        ret = nvn_disassemble(nvname, &radio_index, &bssid_index, (char *)&buf, sizeof(buf));
+        if (ret != WLMDM_OK)
+        {
+            cmsLog_error("Failed to parse nvname: %s", nvname);
+            return ret;
+        }
+
+        ret = nvn_gen("bw", radio_index, -1, (char *)&buf, sizeof(buf));
+        if (ret == WLMDM_OK)
+        {
+            ret = conv_get_mapped((char *)&buf, (char *)&buf_1, sizeof(buf_1));
+            if (ret == WLMDM_OK)
+            {
+                long int b;
+                b = strtol((char *)&buf_1, NULL, 10);
+                if ((b >= 0) && (b < LONG_MAX))
+                {
+                    /*
+                     * translate bw_cap to chanspec.band_width.
+                     * for example: bw_cap = 0x7 -> 20/40/80MHz
+                     * chanspec.band_width will be WL_CHANSPEC_BW_80 as max bandwidth of the specified capability
+                     */
+                    chanspec->band_width = WL_BW_CAP_160MHZ(b) ? WL_CHANSPEC_BW_160 :
+                                           (WL_BW_CAP_80MHZ(b) ? WL_CHANSPEC_BW_80 :
+                                           (WL_BW_CAP_40MHZ(b) ? WL_CHANSPEC_BW_40 :
+                                           (WL_BW_CAP_20MHZ(b) ? WL_CHANSPEC_BW_20 : 0)));
+                }
+                else
+                {
+                    cmsLog_error("Failed to convert %s to proper long int value!", buf_1);
+                }
+            }
+        }
+
+        autoChannel = _get_auto_channel(radio_index);
+        if ((autoChannel != 0))
+        { /* Nothing to do with AutoChannel + AutoSideBand */
+            cmsLog_debug("No Channel from MDM");
+            break;
+        }
+
+        ret = nvn_gen("channel", radio_index, -1, (char *)&buf, sizeof(buf));
+        if (ret == WLMDM_OK)
+        {
+            ret = conv_get_mapped((char *)&buf, (char *)&buf_1, sizeof(buf_1));
+            if (ret == WLMDM_OK)
+            {
+                b = strtol((char *)&buf_1, NULL, 10);
+                if ((b < 0) || (b == LONG_MAX))
+                {
+                    cmsLog_error("Failed to convert %s to proper long int value!", buf_1);
+                    break;
+                }
+                else
+                {
+                    channel = (unsigned int) b;
+                }
+            }
+        }
+
+        ret = nvn_gen("nband", radio_index, -1, (char *)&buf, sizeof(buf));
+        if (ret == WLMDM_OK)
+        {
+            ret = conv_get_mapped((char *)&buf, (char *)&buf_1, sizeof(buf_1));
+            if (ret == WLMDM_OK)
+            {
+                if (0 == strcmp((char *)buf_1, "1"))
+                {
+                    chanspec->band = WL_CHANSPEC_BAND_5G;
+                }
+                else if (0 == strcmp((char *)buf_1, "2"))
+                {
+                    chanspec->band = WL_CHANSPEC_BAND_2G;
+                }
+                else
+                {
+                    chanspec->band = WL_CHANSPEC_BAND_6G;
+                }
+            }
+        }
+
+        /* Handle Auto Side Band Select */
+        switch (chanspec->band_width)
+        {
+            case WL_CHANSPEC_BW_40:
+                /* Auto side band base on channel on 40Mhz
+                   CH 1 -->  7 => "lower"
+                   CH 8 --> 14 => "upper"
+                   For 5G : use lowest channel as control channel
+                */
+                if(chanspec->band == WL_CHANSPEC_BAND_2G)
+                {
+                    chanspec->ctlsb_index = chanspec_get_sb_index((channel < 8) ? "lower" : "upper");
+                    cmsLog_debug("Auto sideband CH:%d  SB:%d",channel,chanspec->ctlsb_index);
+                }else
+                {
+                    /* use lowest channel as control channel */
+                    chanspec->ctlsb_index = 0; 
+                }
+                break;
+    
+            default:
+            case WL_CHANSPEC_BW_80:
+            case WL_CHANSPEC_BW_160:
+                /* use lowest channel as control channel */
+                chanspec->ctlsb_index = 0; 
+                break;
+        }
+
+    }while(0);
+
+    if(str = chanspec_get_sb_string(chanspec->ctlsb_index, chanspec->band_width))
+    {
+        strncpy(value, str, size - 1);
+        ret = WLMDM_OK;
+    }else
+    {
+        ret = WLMDM_GENERIC_ERROR;
+    }
+
+    return ret;
+}
+
+static WlmdmRet foreach_nctrlsb(nvc_for_each_func foreach_func, void *data)
+{
+    int i, num_radio;
+    char nvname[MAX_NVRAM_NAME_SIZE] = {0}, value[MAX_NVRAM_VALUE_SIZE] = {0};
+    WlmdmRet ret;
+
+    num_radio = get_num_instances(MDMOID_DEV2_WIFI_RADIO);
+    for (i = 0; i < num_radio; i++)
+    {
+        ret = nvn_gen("mdmsideband", i, -1, (char *)&nvname, sizeof(nvname));
+        if (ret == WLMDM_OK)
+        {
+            ret = get_nctrlsb(nvname,&value,MAX_NVRAM_VALUE_SIZE);
+            if (ret == WLMDM_OK)
+            {
+                ret = nvn_gen("nctrlsb", i, -1, (char *)&nvname, sizeof(nvname));
+                foreach_func(nvname, value, data);
+            }
+        }
+    }
+    return WLMDM_OK;
+}
