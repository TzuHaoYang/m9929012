//////////////////////////////////////////////////////////////////////////////////////
//
// module: bc_url.c
//
// description: code class to parse a URL into its component parts and do other
//				useful things.
//
// history:
//			date			who		what
//			====			===		====
//
//               CONFIDENTIAL and PROPRIETARY MATERIALS
//
//		This source code is covered by the BrightCloud End User License
//		Agreement for Software Development Kit. Please read the terms of
//		this license before altering or copying the source code.  If you
//		are not willing to be bound by those terms, you may not view or
//		use this source code.
//
//					Export Restrictions
//
//		This source code is subject to the U.S. Export Administration
//		Regulations and other U.S. laws, and may not be exported or
//		re-exported to certain countries (currently Cuba, Iran, Libya,
//		North Korea, Sudan and Syria) or to persons or entities
//		prohibited from receiving U.S. exports (including those (a)
//		on the Bureau of Industry and Security Denied Parties List or
//		Entity List, (b) on the Office of Foreign Assets Control list
//		of Specially Designated Nationals and Blocked Persons, and (c)
//		involved with missile technology or nuclear, chemical or
//		biological weapons).
//
//                        Copyright(c) 2006 - 2011
//                              Webroot, Inc.
//                           4365 Executive Drive
//                           San Diegp, CA 92121
//                             (760) 845-4309
//                           www.brightcloud.com
//
//////////////////////////////////////////////////////////////////////////////////////
/* Copyright 2000-2005 The Apache Software Foundation or its licensors, as
 * applicable.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "bc_url.h"
#include "bc_string.h"
#include "bccsdk.h"
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <assert.h>

#ifndef MIN
#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#endif

// BEGIN - MODIFIED Apache Code (apr_uri)
/* We have a table that we can index by character and it tells us if the
 * character is one of the interesting delimiters.  Note that we even get
 * compares for NUL for free -- it's just another delimiter.
 */
#define T_COLON       0x01        /* ':' */
#define T_SLASH       0x02        /* '/' */
#define T_QUESTION    0x04        /* '?' */
#define T_HASH        0x08        /* '#' */
#define T_RETURN		  0x10		  /* '\n' */
#define T_NUL         0x80        /* '\0' */

/* this file is automatically generated by gen_uri_delims, do not edit */
static const unsigned char uri_delims[256] = {
    T_NUL,0,0,0,0,0,0,0,0,0,T_RETURN,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,T_HASH,0,0,0,0,
    0,0,0,0,0,0,0,T_SLASH,0,0,0,0,0,0,0,0,0,0,T_COLON,0,
    0,0,0,T_QUESTION,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

/* it works like this:
   if (uri_delims[ch] & NOTEND_foobar) {
   then we're not at a delimiter for foobar
   }
*/

/* Note that we optimize the scheme scanning here, we cheat and let the
 * compiler know that it doesn't have to do the & masking.
 */
#define NOTEND_SCHEME     (0xff)
#define NOTEND_HOSTINFO   (T_SLASH | T_QUESTION | T_HASH | T_RETURN | T_NUL)
#define NOTEND_PATH       (T_QUESTION | T_HASH | T_NUL)
// END - MODIFIED Apache Code (apr_uri)

static void set_hostname(char* dest, const char* s, int n) {
    n = MIN(BCA_URL_LENGTH, n);
    bc_strncpy(dest, s, n);
    dest[n] = '\0';

    // trim
    if (n > 0) {
	int i = n - 1;
	while (isspace(dest[i]) || dest[i] == '.') {
	    dest[i] = '\0';
	    if (--i < 0)
		break;
	}
    }
    // lower case for host
    bc_strtolower(dest, BCA_URL_LENGTH);
}

static void set_path(char* dest, const char* s, int n) {
    /* skip first char if path separator - we don't store this */
    if (s[0] == '/' || s[0] == '\\') {
	s++;
    }
    n = MIN(BCA_URL_LENGTH, n );
    bc_strncpy(dest, s, n);
    dest[n] = '\0';

    /* don't store trailing ? as part of the path */
    if (dest[n - 1] == '?')
	dest[n - 1] = '\0';

    /* don't store trailing # as part of the path */
    if (dest[n - 1] == '#')
	dest[n - 1] = '\0';
}

static int find_auth_delimiter(const char* url) {
    const char* p = 0;
    /* look for // to delimit authority, and must be found
     * near the beginning of the URL string.
     */
    return (((p = strstr(url, "://")) != 0) && p - url < 8);
}

struct host_and_path {
    char host[BCA_URL_LENGTH];
    char path[BCA_URL_LENGTH];
};

// BEGIN - MODIFIED Apache Code (apr_uri)
/* Here is the hand-optimized parse_uri_components().  There are some wild
 * tricks we could pull in assembly language that we don't pull here... like we
 * can do word-at-time scans for delimiter characters using the same technique
 * that fast memchr()s use.  But that would be way non-portable. -djg
 */


/* parse_uri_components():
 * Parse a given URI, fill in all supplied fields of a uri_components
 * structure. This eliminates the necessity of extracting host, port,
 * path, query info repeatedly in the modules.
 * Side effects:
 *  - fills in fields of uri_components *uptr
 *  - none on any of the r->* fields
 */
static int parse_url(const char* uri_in, struct host_and_path* hp) {
    const char *s;
    const char *l_hostinfo;
    char* e;
    char* endstr = 0;
    size_t port_len = 0;
    int v6_offset1 = 0;
    int v6_offset2 = 0;
    char port_str[16];
    char buf[BCA_URL_LENGTH];
    const char* uri = buf;
    if (!hp) {
	return -1;
    }
    hp->host[0] = '\0';
    hp->path[0] = '\0';

    /*
     * if no authority delimiters found, add some up front and make an
     * assumption that the first token is an authority
     */
    if (find_auth_delimiter(uri_in)) {
	int n = MIN(BCA_URL_LENGTH - 1, (int)strlen(uri_in) );
	strncpy(buf, uri_in, n);
	buf[n] = '\0';
    } else {
	// saves a working copy prepended with // to help the parser
	// artifically determine that the first token of the path is
	// actually the authority name.
	e = bc_strncpy(buf, "//", 3);
	bc_cpystrn(e, uri_in, BCA_URL_LENGTH - 2);
    }

    /* We assume the processor has a branch predictor like most --
     * it assumes forward branches are untaken and backwards are taken.  That's
     * the reason for the gotos.  -djg
     */

    if (uri[0] == '/') {
	/* RFC2396 #4.3 says that two leading slashes mean we have an
	 * authority component, not a path!  Fixing this looks scary
	 * with the gotos here.  But if the existing logic is valid,
	 * then presumably a goto pointing to deal_with_authority works.
	 *
	 * RFC2396 describes this as resolving an ambiguity.  In the
	 * case of three or more slashes there would seem to be no
	 * ambiguity, so it is a path after all.
	 */
	if (uri[1] == '/' && uri[2] != '/') {
	    s = uri + 2 ;
	    goto deal_with_authority;
	}
      deal_with_path:
	/* we expect uri to point to first character of path ... remember
	 * that the path could be empty -- http://foobar?query for example
	 */
	s = uri;
	while ((uri_delims[*(unsigned char *)s] & NOTEND_PATH) == 0) {
	    ++s;
	}
	if (s != uri) {
	    set_path(hp->path, uri, s - uri);
	    // convert all %__ coded characters before comparisons / storage into DB
	    //unescape(hp->path);
	}
	return 0;
    }
    /* find the scheme: */
    s = uri;
    while ((uri_delims[*(unsigned char *)s] & NOTEND_SCHEME) == 0) {
	++s;
    }
    /* scheme must be non-empty and followed by :// */
    if (s == uri || s[0] != ':' || s[1] != '/' || s[2] != '/') {
	goto deal_with_path;        /* backwards predicted taken! */
    }
    s += 3;

  deal_with_authority:
    l_hostinfo = s;
    while ((uri_delims[*(unsigned char *)s] & NOTEND_HOSTINFO) == 0) {
	++s;
    }
    uri = s;        /* whatever follows hostinfo is start of uri */

    /* If there's a username:password@host:port, the @ we want is the last @...
     * too bad there's no memrchr()... For the C purists, note that hostinfo
     * is definately not the first character of the original uri so therefore
     * &hostinfo[-1] < &hostinfo[0] ... and this loop is valid C.
     */
    do {
	--s;
    } while (s >= l_hostinfo && *s != '@');
    if (s < l_hostinfo) {
	/* again we want the common case to be fall through */
      deal_with_host:
	/* We expect hostinfo to point to the first character of
	 * the hostname.  If there's a port it is the first colon,
	 * except with IPv6.
	 */
	if (*l_hostinfo == '[') {
	    v6_offset1 = 1;
	    v6_offset2 = 2;
	    s = (const char *)memchr(l_hostinfo, ']', uri - l_hostinfo);
	    if (s == NULL) {
		return -1;
	    }
	    if (*++s != ':') {
		s = NULL; /* no port */
	    }
	} else {
	    s = (const char *)memchr(l_hostinfo, ':', uri - l_hostinfo);
	}
	if (s == NULL) {
	    /* we expect the common case to have no port */
	    set_hostname(hp->host, l_hostinfo + v6_offset1,
			 uri - l_hostinfo - v6_offset2);
	    goto deal_with_path;
	}
	set_hostname(hp->host, l_hostinfo + v6_offset1,
		     s - l_hostinfo - v6_offset2);
	++s;
	port_len = MIN((int)sizeof(port_str) - 1, uri - s);
	bc_strncpy(port_str, s, port_len);
	port_str[port_len] = '\0';
	if (uri != s) {
	    strtol(port_str, &endstr, 10);
	    if (*endstr == '\0') {
		goto deal_with_path;
	    }
	    /* Invalid characters after ':' found */
	    return -1;
	}
	goto deal_with_path;
    }
    l_hostinfo = s + 1;
    goto deal_with_host;
}
// END - MODIFIED Apache Code (apr_uri)

static int is_sep(char c) {
    static const char Seps[] = { '/', ';', ':', '&' };
    static const size_t SepCount = sizeof(Seps) / sizeof(char);
    unsigned int i;
    for (i = 0; i < SepCount; ++i)
	{
	    if (Seps[i] == c)
		return 1;
	}
    return 0;
}
/* special handling for non-standard queries */
static void clean_path(char* path)
{
    char* p;
    // first strip off any CR/NL's (embedded http headers)
    // need to look for both separately
    if ((p = strchr(path, '\r')))
	*p = '\0';
    if ((p = strchr(path, '\n')))
	*p = '\0';
    // look for a query parameter assignment and backtrack to a sep
    if ((p = strchr(path, '='))) {
	*p-- = '\0';
	while (path < p) {
	    if (is_sep(*p)) {
		*p = '\0';
		break;
	    }
	    --p;
	}
    }
    // lastly look for the start of a query
    if ((p = strchr(path, '?')))
	*p = '\0';
}

int bc_extract_url(char* dest, const char* url, size_t n)
{
    struct host_and_path hp;
    const char* host;
    char* end;
    size_t remaining = n;

    if (!dest) {
	assert(dest);
	return -1;
    }
    *dest = '\0';
    if (!url || n == 0) {
	return -1;
    }
    if (parse_url(url, &hp) != -1) {
	host = hp.host;
	if (host[0] == 'w' && host[1] == 'w' &&
	    host[2] == 'w' && host[3] == '.') {
	    if (strchr(host + 4, '.') != 0)
		host += 4;
	}
	end = bc_cpystrn(dest, host, remaining);
	// lower case host
	bc_strlower(dest);
	if (hp.path[0] != '\0') {
	    *end++ = '/';
	    remaining -= end - dest;
	    clean_path(hp.path);
	    end = bc_cpystrn(end, hp.path, remaining);
	}
	while (end > dest && *--end == '/')
	    *end = '\0';
	return 0;
    }
    return -1;
}


int bc_extract_host(char* dest, const char* url, size_t n) {
    struct host_and_path hp;
    const char* host;
    if (!dest) {
	assert(dest);
	return -1;
    }
    *dest = '\0';
    if (!url || n == 0) {
	return -1;
    }
    if (parse_url(url, &hp) != -1) {
	host = hp.host;
	if (host[0] == 'w' && host[1] == 'w' &&
	    host[2] == 'w' && host[3] == '.') {
	    if (strchr(host + 4, '.') != 0)
		host += 4;
	}
	bc_cpystrn(dest, host, n);
	// lower case everything to match BcSdk and db
	bc_strlower(dest);
	return 0;
    }
    return -1;
}
