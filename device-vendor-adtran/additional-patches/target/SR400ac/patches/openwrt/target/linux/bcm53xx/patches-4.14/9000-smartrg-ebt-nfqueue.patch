Index: linux-5.4.65/include/linux/netfilter_bridge/ebt_nfqueue.h
===================================================================
--- /dev/null
+++ linux-5.4.65/include/linux/netfilter_bridge/ebt_nfqueue.h
@@ -0,0 +1,10 @@
+#ifndef __LINUX_BRIDGE_EBT_NFQUEUE_H
+#define __LINUX_BRIDGE_EBT_NFQUEUE_H
+#include <linux/types.h>
+
+struct xt_NFQ_info {
+	__u16 queuenum;
+	int target;
+};
+
+#endif
Index: linux-5.4.65/net/bridge/netfilter/Kconfig
===================================================================
--- linux-5.4.65.orig/net/bridge/netfilter/Kconfig
+++ linux-5.4.65/net/bridge/netfilter/Kconfig
@@ -216,6 +216,15 @@ config BRIDGE_EBT_SNAT
 	  source address of frames.
 
 	  To compile it as a module, choose M here.  If unsure, say N.
+
+config BRIDGE_EBT_NFQUEUE
+	tristate "ebt: nfqueue target support"
+	help
+	  This option adds the nfqueue target for ebtables, which delegates the
+	  decision on packets to a userspace software.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 #
 # watchers
 #
Index: linux-5.4.65/net/bridge/netfilter/Makefile
===================================================================
--- linux-5.4.65.orig/net/bridge/netfilter/Makefile
+++ linux-5.4.65/net/bridge/netfilter/Makefile
@@ -37,6 +37,7 @@ obj-$(CONFIG_BRIDGE_EBT_MARK_T) += ebt_m
 obj-$(CONFIG_BRIDGE_EBT_DNAT) += ebt_dnat.o
 obj-$(CONFIG_BRIDGE_EBT_REDIRECT) += ebt_redirect.o
 obj-$(CONFIG_BRIDGE_EBT_SNAT) += ebt_snat.o
+obj-$(CONFIG_BRIDGE_EBT_NFQUEUE) += ebt_nfqueue.o
 
 # watchers
 obj-$(CONFIG_BRIDGE_EBT_LOG) += ebt_log.o
Index: linux-5.4.65/net/bridge/netfilter/ebt_nfqueue.c
===================================================================
--- /dev/null
+++ linux-5.4.65/net/bridge/netfilter/ebt_nfqueue.c
@@ -0,0 +1,76 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_bridge/ebtables.h>
+#include <linux/netfilter_bridge/ebt_nfqueue.h>
+
+MODULE_AUTHOR("alibaba");
+MODULE_DESCRIPTION("ebtables: forwarding to netlink");
+MODULE_LICENSE("GPL");
+
+static unsigned int ebt_nfqueue_tg(struct sk_buff *skb, const struct xt_action_param *par) {
+	const struct xt_NFQ_info *info = par->targinfo;
+
+	return NF_QUEUE_NR(info->queuenum);
+}
+
+static int ebt_nfqueue_tg_check(const struct xt_tgchk_param* par) {
+	const struct xt_NFQ_info *info = par->targinfo;
+
+	if (BASE_CHAIN && info->target == EBT_RETURN) {
+		printk(KERN_INFO"ebt_nfqueue: ebt_nfqueue_tg_check failed\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+static void dummy_from_user(void *dst, const void *src) {
+}
+
+static int dummy_to_user(void __user *dst, const void *src) {
+	return 0;
+}
+#endif
+
+static struct xt_target nfqueue_tg_reg __read_mostly = {
+	.name           = "nfqueue",
+	.revision   = 0,
+	.family     = NFPROTO_BRIDGE,
+	.table      = "filter",
+	.hooks      = (1 << NF_BR_NUMHOOKS) | (1 << NF_BR_LOCAL_IN) | (1 << NF_BR_LOCAL_OUT) | (1 << NF_BR_FORWARD),
+	.target         = ebt_nfqueue_tg,
+	.checkentry     = ebt_nfqueue_tg_check,
+	.targetsize     = XT_ALIGN(sizeof(struct xt_NFQ_info)),
+#ifdef CONFIG_COMPAT
+	.compat_from_user = dummy_from_user,
+	.compat_to_user = dummy_to_user,
+#endif
+	.me             = THIS_MODULE,
+};
+
+static int __init nfqueue_tg_init(void)
+{
+	return xt_register_target(&nfqueue_tg_reg);
+}
+
+static void __exit nfqueue_tg_exit(void)
+{
+	xt_unregister_target(&nfqueue_tg_reg);
+}
+
+module_init(nfqueue_tg_init);
+module_exit(nfqueue_tg_exit);
+MODULE_DESCRIPTION("Ebtables: NFQUEUE target");
+MODULE_LICENSE("GPL");
Index: linux-5.4.65/net/bridge/netfilter/ebtables.c
===================================================================
--- linux-5.4.65.orig/net/bridge/netfilter/ebtables.c
+++ linux-5.4.65/net/bridge/netfilter/ebtables.c
@@ -270,6 +270,17 @@ letsreturn:
 			return NF_DROP;
 		}
 
+		/*
+		 * We add NFQUEUE support in ebtables here:
+		 *
+		 * If verdict is NF_QUEUE type, pass it to Netfilter. Netfilter will
+		 * call nf_queue to handle this.
+		 */
+		if (verdict > 0 && (verdict & NF_VERDICT_MASK) == NF_QUEUE) {
+			read_unlock_bh(&table->lock);
+			return verdict;
+		}
+
 		/* jump to a udc */
 		cs[sp].n = i + 1;
 		cs[sp].chaininfo = chaininfo;
