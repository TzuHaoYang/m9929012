From ec6567f55e9a8bb4578caaaeea3693036f356de6 Mon Sep 17 00:00:00 2001
From: James Wu <jwu@plume.com>
Date: Fri, 4 Jun 2021 11:43:36 +0800
Subject: [PATCH] qm: fix qm_conn stuck issue

It's found FSM no longer inject DNS responses after we block tcp:443
traffic during test. It turns out when FSM tries to send DNS report to
MQTT broker via QM, qm_conn in FSM never has a chance to receive reply
from QM.

Added a default timeout of 2 seconds when sending messages to QM.
In addition, added APIs to control the timeout (0 = no timeout):
- qm_conn_set_default_timeout(double timeout);
- qm_conn_set_fd_timeout(int fd, double timeout);

Signed-off-by: James Wu <jwu@plume.com>
---
 .../810-qm-fix-qm-conn-stuck-issue.patch      | 94 +++++++++++++++++++
 1 file changed, 94 insertions(+)
 create mode 100644 feeds/wlan-ap-consumer/opensync/patches/810-qm-fix-qm-conn-stuck-issue.patch

diff --git a/feeds/wlan-ap-consumer/opensync/patches/810-qm-fix-qm-conn-stuck-issue.patch b/feeds/wlan-ap-consumer/opensync/patches/810-qm-fix-qm-conn-stuck-issue.patch
new file mode 100644
index 00000000..0629e74d
--- /dev/null
+++ b/feeds/wlan-ap-consumer/opensync/patches/810-qm-fix-qm-conn-stuck-issue.patch
@@ -0,0 +1,94 @@
+--- a/src/qm/qm_conn/src/qm_conn.c
++++ b/src/qm/qm_conn/src/qm_conn.c
+@@ -44,6 +44,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
+ #define QM_SOCK_MAX_PENDING 10
+ #define QM_COMPACT_SEND_SIZE (64*1024)
+ 
++static double qm_conn_default_timeout = QM_CONN_DEFAULT_TIMEOUT;
++
+ extern const char *log_get_name();
+ 
+ // server
+@@ -100,6 +102,28 @@ bool qm_conn_accept(int listen_fd, int *
+ 
+ // client
+ 
++void qm_conn_set_default_timeout(double timeout)
++{
++    qm_conn_default_timeout = timeout;
++}
++
++bool qm_conn_set_fd_timeout(int fd, double timeout)
++{
++    int ret;
++    struct timeval tv;
++    tv.tv_sec = (int)timeout;
++    tv.tv_usec = (int)((timeout - (int)timeout) * 1000000.0);
++    ret = setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv, sizeof tv);
++    if (ret != 0) goto error;
++    ret = setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, (const char*)&tv, sizeof tv);
++    if (ret != 0) goto error;
++    return true;
++error:
++    LOGE("setsockopt(%d,%f) = %d %d", fd, timeout, ret, errno);
++    return false;
++}
++
++
+ bool qm_conn_client(int *pfd)
+ {
+     struct sockaddr_un addr;
+@@ -115,6 +139,14 @@ bool qm_conn_client(int *pfd)
+         return false;
+     }
+ 
++    // set timeout; if 0 then never timeout
++    if (qm_conn_default_timeout > 0) {
++        if (!qm_conn_set_fd_timeout(fd, qm_conn_default_timeout)) {
++            close(fd);
++            return false;
++        }
++    }
++
+     memset(&addr, 0, sizeof(addr));
+     addr.sun_family = AF_UNIX;
+     if (*path == '\0') {
+--- a/src/qm/qm_conn/src/qm_conn.h
++++ b/src/qm/qm_conn/src/qm_conn.h
+@@ -34,6 +34,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
+ 
+ #define QM_REQUEST_TAG "QREQ"
+ #define QM_REQUEST_VER 2
++#define QM_CONN_DEFAULT_TIMEOUT 2.0 // timeout in seconds (float)
+ 
+ enum qm_req_cmd
+ {
+@@ -141,6 +142,28 @@ bool qm_conn_accept(int listen_fd, int *
+ bool qm_conn_server(int *pfd);
+ bool qm_conn_client(int *pfd);
+ 
++/**
++ * @brief Set the qm_conn default timeout
++ *
++ * This overrides the default timeout of QM_CONN_DEFAULT_TIMEOUT
++ * If set to 0 then never timeout
++ *
++ * @param timeout timeout in seconds (float)
++ */
++void qm_conn_set_default_timeout(double timeout);
++
++/**
++ * @brief Set the qm_conn timeout for a specific session
++ *
++ * This overrides the qm_conn timeout for a specific session
++ * If set to 0 then never timeout
++ *
++ * @param fd qm_conn session
++ * @param timeout timeout in seconds (float)
++ */
++bool qm_conn_set_fd_timeout(int fd, double timeout);
++
++
+ void qm_req_init(qm_request_t *req);
+ bool qm_req_valid(qm_request_t *req);
+ bool qm_conn_write_req(int fd, qm_request_t *req, char *topic, void *data, int data_size);
-- 
2.25.1

